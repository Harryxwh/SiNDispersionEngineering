###############################################################################
# This script is used to find the dispersion of the eigenmode of two horizontally coupled rings.
# This is a direct calculation of the supermodes of coupled WGs
# Since FDE is a 2D solver focused on the cross section, the result does not depend on the geometry in z direction.

# Author: Weihao Xu
# Date: May. 5th, 2025
# Email: harryxwh@gmail.com
###############################################################################

switchtolayout;
deleteall;

um = 1e-6;
nm = 1e-9;

# Mesh settings
mesh_cells_x = 3000;
mesh_cells_y = 1000;

material_core = "Si3N4 (Silicon Nitride) - Luke";
material_clad = "SiO2 (Glass) - Palik";

# name of the folder to store data
folder_name = "Dispersion_2D_concentric_rings" + "\\";

# Scanning the gap between the sidewalls of the two WGs
gap_min         = 2.6   *um;
gap_max         = 3.4   *um;
num_sweep_pt    = 5;
gap_array       = linspace(gap_min,gap_max,num_sweep_pt);

wavelength      = 1550*nm;

for(gap = gap_array){

    switchtolayout;
    deleteall;

    format short;
    ?"gap = " + num2str(gap /um) +"um";

    # File to store the dispersion curve at given gap
    D_filename  = folder_name+ "gapx_"+num2str(gap /um)+"um.txt";
    if(fileexists(D_filename)){rm(D_filename);}
    write(D_filename,"Wavelength (microns), Dispersion (us/nm/km)");

    # Geometry
    # Inner Ring
    Lx_WG1 = 8*um; # width of the WG
    Ly_WG1 = 0.1*um; # height of the WG
    Lz_WG1 = 10*um; # length of the WG

    # Outer Ring
    # Calculate the width of the outer ring satisfying the phase matching condition
    # The formula comes from a polynomial fit of simulation data
    Lx_WG2 = (9.92857*(gap /um)^2 - 242.2928*(gap /um) + 3399.5714) * nm;
    Ly_WG2 = 0.1*um; # height of the WG

    Lx_Cladding = 50*um;            # width of the cladding layer
    Ly_Cladding = 2*um;             # height of the cladding layer

    Lx_Buried_Oxide = 50*um;        # width of the BOX layer
    Ly_Buried_Oxide = 14.5*um;      # height of the BOX layer

    Lx_FDE = 45*um;                 # width of the FDE solver region
    Ly_FDE_min = -10*um;            # ymin of the FDE solver region
    Ly_FDE_max = 5*um;              # ymax of the FDE solver region

    bend_radius_inner   =  1000*um;
    bend_radius         =  bend_radius_inner + Lx_WG1*0.5 + gap*0.5;
    ?"bend_radius = "   + num2str(bend_radius /um)+" um";

    # Inner Ring
    addrect;
    set("name","Inner Ring");
    set("x",-Lx_WG1/2 - gap/2);
    set("x span",Lx_WG1);
    set("y min",0);
    set("y max",Ly_WG1);
    set("override mesh order from material database",true);
    set("mesh order",2);
    set("material",material_core);

    # Outer Ring
    addrect;
    set("name","Outer Ring");
    set("x",Lx_WG2/2 + gap/2);
    set("x span",Lx_WG2);
    set("y min",0);
    set("y max",Ly_WG2);
    set("override mesh order from material database",true);
    set("mesh order",2);
    set("material",material_core);

    # BOX
    addrect;
    set("name","BOX");
    set("x",0);
    set("x span",Lx_Buried_Oxide);
    set("y max",0);
    set("y min",-Ly_Buried_Oxide);
    #set("z",0);
    #set("z span",Lz_Buried_Oxide);
    set("override mesh order from material database",true);
    set("mesh order",3);
    set("material",material_clad);

    # Cladding
    addrect;
    set("name","Cladding");
    set("x",0);
    set("x span",Lx_Cladding);
    set("y min",0);
    set("y max",Ly_Cladding);
    #set("z",0);
    #set("z span",Lz_Cladding);
    set("override mesh order from material database",true);
    set("mesh order",3);
    set("material",material_clad);

    # FDE solver region
    addfde;
    set("solver type","2D Z normal");
    set("x",0*um);
    set("y",0);
    set("x span",Lx_FDE);
    set("y min",Ly_FDE_min);
    set("y max",Ly_FDE_max);
    set("x min bc","PML");
    set("x max bc","PML");
    set("y min bc","PML");
    set("y max bc","PML");
    set("define x mesh by","number of mesh cells");
    set("define y mesh by","number of mesh cells");
    set("mesh cells x",mesh_cells_x);
    set("mesh cells y",mesh_cells_y);
    setnamed("FDE","wavelength",wavelength);

    set("bent waveguide", 1);
    set("bend location x", 0);
    set("bend location y", 0);
    set("bend location z", 0);
    set("bend radius",bend_radius);

    addmesh;
    set("name","mesh_waveguide");
    set("x min",-gap/2 - Lx_WG1 - 1*um);
    set("x max", gap/2 + Lx_WG2 + 1*um );
    set("y min",0 - 1*um);
    set("y max",Ly_WG1 + 1*um);
    set("override x mesh",1);
    set("override y mesh",1);
    set("override z mesh",0);
    set("set maximum mesh step",1);
    set("dx",10*nm);
    set("dy",10*nm);

    findmodes;

    # Selecting the anti-symmetric mode
    selectmode(2);

    # Starting from wavl as defined in "wavelength" (e.g. 1550*nm)
    # Scanning longer wavls
    setanalysis("track selected mode",1);
    setanalysis("detailed dispersion calculation",1);
    setanalysis("store mode profiles while tracking",1);
    setanalysis("stop wavelength",1.6*um);
    setanalysis("number of points",10);
    frequencysweep;

    format long;
    # The unit is us/nm/km (need another factor of 1e-6 to become ps/nm/km)
    D        = getdata("frequencysweep","D");
    # The unit is Hz
    f        = getdata("frequencysweep","f_D");
    data_arr = [flip(f,1),flip(D,1)];       # the arrays need to be fliped to keep the whole file sorted
    write(D_filename,num2str(data_arr));

    # Scanning shorter wavls
    selectmode(2);
    setanalysis("track selected mode",1);
    setanalysis("detailed dispersion calculation",1);
    setanalysis("store mode profiles while tracking",1);
    setanalysis("stop wavelength",1.5*um);
    setanalysis("number of points",10);
    frequencysweep;

    format long;
    # The unit is us/nm/km (need another factor of 1e-6 to become ps/nm/km)
    D        = getdata("frequencysweep","D");
    # The unit is Hz
    f        = getdata("frequencysweep","f_D");
    data_arr = [f,D];
    write(D_filename,num2str(data_arr));

}
