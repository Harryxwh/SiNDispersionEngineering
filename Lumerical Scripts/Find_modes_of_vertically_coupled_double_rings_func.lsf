###############################################################################
# This script is a function used to find the eigenmodes of two vertically coupled rings when the vertical gap is given.
# Since FDE is a 2D solver focused on the cross section, the result does not depend on the geometry in z direction.

# Parameters:

# Lower Ring
# Lx_upper          :   width of the WG of Upper ring
# Ly_upper          :   thickness of the WG2 of Upper ring

# Upper Ring
# Lx_lower          :   width of the WG of Lower ring
# Ly_lower          :   thickness of the WG of Lower ring

# Cladding layer
# Lx_Cladding       :   width of the claddin layer
# Ly_Cladding       :   thickness of the cladding layer

# Box layer
# Lx_Buried_Oxide   :   width of the BOX layer
# Ly_Buried_Oxide   :   thickness of the BOX layer

# FDE region
# Lx_FDE            :   width of the FDE solver region
# Ly_FDE_min        :   ymin of the FDE solver region
# Ly_FDE_max        :   ymax of the FDE solver region

# Mesh settings
# mesh_cells_x      :   num of mesh cells in x direction
# mesh_cells_y      :   num of mesh cells in y direction

# bend_radius_inner :   bending radius of the inner WG

# material_core     :   material of the WG core, e.g. "Si3N4 (Silicon Nitride) - Luke";
# material_clad     :   material of the WG cladding, e.g. "SiO2 (Glass) - Palik";

# Max_Mode_Idx      :   num of eigenmodes to save into txt files. e.g. 2

# Define wavelength of simulation
# wavelength_min    :   starting wavelength
# wavelength_max    :   stoping wavelength
# num_sweep_pt_wavl :   num of wavelength points to calculate

# Define gap between the horizontal surfaces of the two WGs
# gap_min           :   starting gap
# gap_max           :   stoping gap
# num_sweep_pt_gap  :   num of gap points to calculate

# Author: Weihao Xu
# Date: May. 5th, 2025
# Email: harryxwh@gmail.com
###############################################################################

switchtolayout;
deleteall;

# Setup the wavelength array
wavelength_array = linspace(wavelength_min,wavelength_max,num_sweep_pt_wavl);

# Setup the gap array
gap_array        = linspace(gap_min,gap_max,num_sweep_pt_gap);

# Create the overall folder
foldername_overall = 'Find_modes_of_vertically_coupled_double_rings_radius_'+num2str(bend_radius/um)+'um_gap_'+num2str(gap_min/nm)+'nm_to_'+num2str(gap_max/nm)+'nm_'+num2str(num_sweep_pt_gap)+'pts_LowerRingWidth_'+num2str(Lx_upper/nm)+'nm_UpperRingWidth_'+num2str(Lx_lower/nm)+'nm_mesh_'+num2str(mesh_cells_x)+'X'+num2str(mesh_cells_y);
system('if exist '+foldername_overall+' rmdir /s /q '+foldername_overall);
system('mkdir '+foldername_overall);
system('cd '+foldername_overall);

for (gap = gap_array)
{
    ?"gap = "+num2str(gap / um)+" um";

    # Create the folder for the current gap
    foldername_gap = 'gap_'+num2str(gap/nm)+'nm';
    system('if exist '+foldername_gap+' rmdir /s /q '+foldername_gap);
    system('mkdir '+foldername_gap);

    # Create folders for each wavl
    for(wavelength = wavelength_array){
        format short;
        foldername_wavl = foldername_gap + '\\' + num2str(wavelength /nm);
        system("mkdir "+foldername_wavl);
    }

    # Store mode attributes (neff, ng, loss, etc.) of all the eigenmodes into one result file
    info_total_filename  = foldername_gap  + '\\' + "Vertically_coupled_double_ring_result.txt";
    if(fileexists(info_total_filename)){rm(info_total_filename);}
    # Print parameters
    write(info_total_filename,"Lx_upper = "+num2str(Lx_upper)+", Ly_upper = " + num2str(Ly_upper));
    write(info_total_filename,"Lx_lower = "+num2str(Lx_lower)+", Ly_lower = " + num2str(Ly_lower));
    write(info_total_filename,"Bending Radius = "+num2str(bend_radius)+", gap_y = " + num2str(gap)+", num of cells = " + num2str(mesh_cells_x)+"X"+num2str(mesh_cells_y));
    # Print header
    write(info_total_filename,"wavelength,modeidx,neff,ng,loss,polarization,beta_ang");

    Comp_name_list = {"Ex","Ey","Ez","Hx","Hy","Hz"};

    for(wavl_idx=1:num_sweep_pt_wavl){

        switchtolayout;

        wavelength = wavelength_array(wavl_idx);

        # Store mode attributes (neff, ng, loss, etc.) of the current wavelength
        format short;
        foldername_wavl = foldername_gap + '\\' + num2str(wavelength /nm);
        info_filename = foldername_wavl + '\\' +  "Mode_info.txt";
        if(fileexists(info_filename)){rm(info_filename);}
        # Print header
        write(info_filename,"wavelength,modeidx,neff,ng,loss,polarization,beta_ang");

        # Lower Ring
        addrect;
        set("name","Lower Ring");
        set("x",0);
        set("x span",Lx_lower);
        set("y min",0);
        set("y max",Ly_lower);
        set("override mesh order from material database",true);
        set("mesh order",2);
        set("material",material_core);

        # Upper Ring
        addrect;
        set("name","Upper Ring");
        set("x",0);
        set("x span",Lx_upper);
        set("y min",gap);
        set("y max",gap+Ly_upper);
        set("override mesh order from material database",true);
        set("mesh order",2);
        set("material",material_core);

        # BOX
        addrect;
        set("name","BOX");
        set("x",0);
        set("x span",Lx_Buried_Oxide);
        set("y max",0);
        set("y min",-Ly_Buried_Oxide);
        set("override mesh order from material database",true);
        set("mesh order",3);
        set("material",material_clad);

        # Cladding
        addrect;
        set("name","Cladding");
        set("x",0);
        set("x span",Lx_Cladding);
        set("y min",0);
        set("y max",Ly_Cladding);
        set("override mesh order from material database",true);
        set("mesh order",3);
        set("material",material_clad);

        # FDE solver region
        addfde;
        set("solver type","2D Z normal");
        set("x",0*um);
        set("y",0);
        set("x span",Lx_FDE);
        set("y min",Ly_FDE_min);
        set("y max",Ly_FDE_max);
        set("x min bc","PML");
        set("x max bc","PML");
        set("y min bc","PML");
        set("y max bc","PML");
        set("define x mesh by","number of mesh cells");
        set("define y mesh by","number of mesh cells");
        set("mesh cells x",mesh_cells_x);
        set("mesh cells y",mesh_cells_y);

        set("bent waveguide", 1);
        set("bend location x", 0);
        set("bend location y", 0);
        set("bend location z", 0);
        set("bend radius",bend_radius);

        set("wavelength",wavelength);

        Lx_ave =  (Lx_lower + Lx_upper)/2;

        # Override the mesh near the lower WG
        addmesh;
        set("name","mesh_waveguide");
        set("x min", -Lx_ave - 1*um);
        set("x max", Lx_ave + 1*um);
        set("y min", 0 - 1*um);
        set("y max", Ly_lower + 1*um);
        set("override x mesh",1);
        set("override y mesh",1);
        set("override z mesh",0);
        set("set maximum mesh step",1);
        set("dx",10*nm);
        set("dy",10*nm);

        # Override the mesh near the upper WG
        addmesh;
        set("name","mesh_waveguide");
        set("x min", -Lx_ave -1*um);
        set("x max", Lx_ave + 1*um);
        set("y min", gap - 1*um);
        set("y max", gap + Ly_upper + 1*um);
        set("override x mesh",1);
        set("override y mesh",1);
        set("override z mesh",0);
        set("set maximum mesh step",1);
        set("dx",10*nm);
        set("dy",10*nm);

        findmodes;

        for (mode_idx=1:Max_Mode_Idx){

            neff =pinch(getdata("FDE::data::mode"+num2str(mode_idx),"neff"));
            ng =pinch(getdata("FDE::data::mode"+num2str(mode_idx),"ng"));
            loss =pinch(getdata("FDE::data::mode"+num2str(mode_idx),"loss"));
            polarization=pinch(getdata("FDE::data::mode"+num2str(mode_idx),"TE polarization fraction"));

            beta_ang = real(2*pi/wavelength * bend_radius * neff);

            Ex = pinch(getdata("FDE::data::mode"+num2str(mode_idx),"Ex"));
            Ey = pinch(getdata("FDE::data::mode"+num2str(mode_idx),"Ey"));
            Ez = pinch(getdata("FDE::data::mode"+num2str(mode_idx),"Ez"));
            Hx = pinch(getdata("FDE::data::mode"+num2str(mode_idx),"Hx"));
            Hy = pinch(getdata("FDE::data::mode"+num2str(mode_idx),"Hy"));
            Hz = pinch(getdata("FDE::data::mode"+num2str(mode_idx),"Hz"));

            Comp_list = {Ex,Ey,Ez,Hx,Hy,Hz};
            format short;
            info = num2str(wavelength /nm) +","+ num2str(mode_idx);
            format long;
            info = info  +","+ num2str(neff) +","+ num2str(ng) +","+ num2str(loss) +","+ num2str(polarization) +","+ num2str(beta_ang);
            write(info_filename,info);
            write(info_total_filename,info);

            # Print the attributes of the first two modes
            if(mode_idx < 3){
                ?"Wavelength: " + num2str(wavelength /um) + " um";
                ?"ModeIdx: " + num2str(mode_idx);
                ?"Effective index: " + num2str(real(neff));
                ?"beta_ang: " + num2str(beta_ang);
                ?"\n";
            }

            # Write mode profile matrix into txt files
            for (j=1:6){
                format short;
                filename = foldername_wavl+'\\'+"Mode"+num2str(mode_idx)+"_"+Comp_name_list{j}+".txt";
                if(fileexists(filename)){
                    rm(filename);
                }
                format long; # set num2str() to return 16 digits of precision
                write(filename,num2str(Comp_list{j}));
            }
        }
    }

}

