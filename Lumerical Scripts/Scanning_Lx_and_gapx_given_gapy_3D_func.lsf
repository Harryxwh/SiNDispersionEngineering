###############################################################################
# This script scans the width of the lower ring (Lx) and the gap between rings (gapx)
# to find the angular propagation constant (Beta_ang) for each configuration.

# Parameters:

# WG
# Ly_lower          :   thickness ofthe WG

# Cladding layer
# Lx_Cladding       :   width of the cladding layer
# Ly_Cladding       :   thickness ofthe cladding layer

# Box layer
# Lx_Buried_Oxide   :   width of the BOX layer
# Ly_Buried_Oxide   :   thickness ofthe BOX layer

# FDE region
# Lx_FDE            :   width of the FDE solver region
# Ly_FDE_min        :   ymin of the FDE solver region
# Ly_FDE_max        :   ymax of the FDE solver region

# Mesh settings
# mesh_cells_x      :   num of mesh cells in x direction
# mesh_cells_y      :   num of mesh cells in y direction

# bend_radius_upper :   bending radius of the upper WG
# gapx_arr          :   array of gapx values to sweep
# Lx_arr            :   array of Lx values to sweep

# material_core     :   material of the WG core, e.g. "Si3N4 (Silicon Nitride) - Luke";
# material_clad     :   material of the WG cladding, e.g. "SiO2 (Glass) - Palik";

# Define wavelength of simulation
# wavelength        :   wavelength of the simulation

# Author: Weihao Xu
# Date: May. 5th, 2025
# Email: harryxwh@gmail.com
###############################################################################

# Housekeeping
switchtolayout;
deleteall;

# Define units
um = 1e-6;
nm = 1e-9;

# Write header in result file
format long;
if(fileexists(filename)){rm(filename);}
header = "gap/L_lower";
for (Lx_idx = 1:num_of_pts_Lx){
    Lx_lower = Lx_arr(Lx_idx);
    header = header + "," + num2str(Lx_lower /um);
}
write(filename,header);

for (gapx_idx = 1:num_of_pts_gapx){
    gapx = gapx_arr(gapx_idx);
    ?"gap_x = " + num2str(gapx /um) + " um";
    Beta_ang_info = num2str(gapx /um) + ",";

    for (Lx_idx = 1:num_of_pts_Lx){
        Lx_lower = Lx_arr(Lx_idx);
        ?"Lx_lower = " + num2str(Lx_lower /um) + " um";

        # Calculate the bending radius
        bend_radius = bend_radius_upper - gapx;
        ?"bend_radius = " + num2str(bend_radius /um) + " um";

        # Switch to layout and clear previous structures
        switchtolayout;
        deleteall;

        # Add waveguide
        addrect;
        set("name", "WG");
        set("x", 0);
        set("x span", Lx_lower);
        set("y min", 0);
        set("y max", Ly_lower);
        set("override mesh order from material database", true);
        set("mesh order", 2);
        set("material", material_core);

        # Add BOX
        addrect;
        set("name", "BOX");
        set("x", 0);
        set("x span", Lx_Buried_Oxide);
        set("y max", 0);
        set("y min", -Ly_Buried_Oxide);
        set("override mesh order from material database", true);
        set("mesh order", 3);
        set("material", material_clad);

        # Add cladding
        addrect;
        set("name", "Cladding");
        set("x", 0);
        set("x span", Lx_Cladding);
        set("y min", 0);
        set("y max", Ly_Cladding);
        set("override mesh order from material database", true);
        set("mesh order", 3);
        set("material", material_clad);

        # Add FDE solver
        addfde;
        set("solver type", "2D Z normal");
        set("x", 0*um);
        set("y", 0);
        set("x span", Lx_FDE);
        set("y min", Ly_FDE_min);
        set("y max", Ly_FDE_max);
        set("x min bc", "PML");
        set("x max bc", "PML");
        set("y min bc", "PML");
        set("y max bc", "PML");
        set("define x mesh by", "number of mesh cells");
        set("define y mesh by", "number of mesh cells");
        set("mesh cells x", mesh_cells_x);
        set("mesh cells y", mesh_cells_y);
        set("bent waveguide", 1);
        set("bend location x", 0);
        set("bend location y", 0);
        set("bend radius", bend_radius);

        # Run mode solver
        findmodes;

        # Extract angular propagation constant
        mode_idx = 1;  # Fundamental mode
        neff = pinch(getdata("FDE::data::mode" + num2str(mode_idx), "neff"));
        Beta_ang = real(2*pi/wavelength * neff * bend_radius);
        ?"Beta_ang = " + num2str(real(Beta_ang));

        format long;
        if(Lx_idx == 1){
            Beta_ang_info = Beta_ang_info + num2str(Beta_ang);
        } else {
            Beta_ang_info = Beta_ang_info + "," + num2str(Beta_ang);
        }
    }

    # Write results to file
    write(filename, Beta_ang_info);
}