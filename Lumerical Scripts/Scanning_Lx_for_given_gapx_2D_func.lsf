###############################################################################
# This script is a function used to find the propagation constant of the outer ring at a fixed wavelength when the gap between the two rings is swept
# Since FDE is a 2D solver focused on the cross section, the result does not depend on the geometry in z direction.

# Parameters:

# Outer ring
# Ly_WG             :   height of the WG1

# Upper Ring
# Lx_WG2            :   width of the WG2
# Ly_WG2            :   height of the WG2

# Cladding layer
# Lx_Cladding       :   width of the claddin layer
# Ly_Cladding       :   height of the cladding layer

# Box layer
# Lx_Buried_Oxide   :   width of the BOX layer
# Ly_Buried_Oxide   :   height of the BOX layer

# Geometry of the inner ring is fixed
# Lx_inner_ring     :   width of the inner ring
# bend_radius_inner :   bending radius of the inner ring

# FDE region
# Lx_FDE            :   width of the FDE solver region
# Ly_FDE_min        :   ymin of the FDE solver region
# Ly_FDE_max        :   ymax of the FDE solver region

# Mesh settings
# mesh_cells_x      :   num of mesh cells in x direction
# mesh_cells_y      :   num of mesh cells in y direction

# gap               :   gap between the horizontal surfaces of the two WGs

# bend_radius_inner :   bending radius of the inner WG

# material_core     :   material of the WG core, e.g. "Si3N4 (Silicon Nitride) - Luke";
# material_clad     :   material of the WG cladding, e.g. "SiO2 (Glass) - Palik";

# Max_Mode_Idx      :   num of eigenmodes to save into txt files. e.g. 2

# filename          :   name of the file to store the data. e.g. "Scanning_Lx_around2um_L_inner_2_8um_gap_3um.txt"

# Define wavelength of simulation
# wavelength        :

# Parameter sweep of width of outer ring
# Lx_start          :   start of the width of outer ring
# Lx_end            :   end of the width of outer ring
# num_of_pts_Lx     :   number of sweeping points

# gap               :   the distance between two the sidewalls of the rings is fixed

# Author: Weihao Xu
# Date: May. 5th, 2025
# Email: harryxwh@gmail.com
###############################################################################

switchtolayout;
deleteall;

Lx_arr          = linspace(Lx_start,Lx_end,num_of_pts_Lx);
beta_ang_array  = zeros(num_of_pts_Lx);

format short;
filename = "Scanning_Lx_from_" + num2str(Lx_start/nm) +"nm_to_"+ num2str(Lx_end/nm) +"nm_InnerWGWidth_" + num2str(Lx_inner_ring/nm)+"nm_gap_"+num2str(gap/nm)+"nm.txt";
if(fileexists(filename)){rm(filename);}
write(filename,"Lx,beta_ang");

for (Lx_idx = 1:num_of_pts_Lx)
{
    Lx_WG = Lx_arr(Lx_idx);
    ?"Lx_WG = " + num2str(Lx_WG /um)+" um";

    # Decide the bending radius based on the waveguide width, for a given gap
    bend_radius = Lx_WG/2 + bend_radius_inner + gap + Lx_inner_ring/2;
    ?"bend_radius = " + num2str(bend_radius /um)+" um";

    switchtolayout;
    deleteall;

    #WG
    addrect;
    set("name","WG");
    set("x",0);
    set("x span",Lx_WG);
    set("y min",0);
    set("y max",Ly_WG);
    #set("z",0);
    #set("z span",Lz_WG);
    set("override mesh order from material database",true);
    set("mesh order",2);
    set("material",material_core);

    # BOX
    addrect;
    set("name","BOX");
    set("x",0);
    set("x span",Lx_Buried_Oxide);
    set("y max",0);
    set("y min",-Ly_Buried_Oxide);
    #set("z",0);
    #set("z span",Lz_Buried_Oxide);
    set("override mesh order from material database",true);
    set("mesh order",3);
    set("material",material_clad);

    # Cladding
    addrect;
    set("name","Cladding");
    set("x",0);
    set("x span",Lx_Cladding);
    set("y min",0);
    set("y max",Ly_Cladding);
    #set("z",0);
    #set("z span",Lz_Cladding);
    set("override mesh order from material database",true);
    set("mesh order",3);
    set("material",material_clad);

    addfde;
    set("solver type","2D Z normal");
    set("x",0*um);
    set("y",0);
    set("x span",Lx_FDE);
    set("y min",Ly_FDE_min);
    set("y max",Ly_FDE_max);

    set("x min bc","PML");
    set("x max bc","PML");
    set("y min bc","PML");
    set("y max bc","PML");
    set("define x mesh by","number of mesh cells");
    set("define y mesh by","number of mesh cells");
    set("mesh cells x",mesh_cells_x);
    set("mesh cells y",mesh_cells_y);

    set("bent waveguide", 1);
    set("bend location x", 0);
    set("bend location y", 0);
    set("bend location z", 0);
    set("bend radius",bend_radius);

    #addmesh;
    #set("name","mesh_waveguide");
    #set("x min",-1.2*um - 0.5*um);
    #set("x max",1.2*um + 0.5*um );
    #set("y min",0-0.5*um);
    #set("y max",Ly_WG + 0.5*um);
    #set("override x mesh",1);
    #set("override y mesh",1);
    #set("override z mesh",0);
    #set("set maximum mesh step",1);
    #set("dx",5*nm);
    #set("dy",5*nm);

    findmodes;

    mode_idx    = 1;    #fundamental mode
    neff        = pinch(getdata("FDE::data::mode"+num2str(mode_idx),"neff"));

    #NOTE: Angular propagation constant is the value with physical meaning. It is important to note that this definition of neff here is dependent on the bending radius R.
    Beta_ang    = real(2*pi/wavelength * neff * bend_radius);
    beta_ang_array(Lx_idx) = Beta_ang;

    format long;
    ?"Beta_ang = " + num2str(real(Beta_ang));

    Beta_ang_given_Lx = num2str(Lx_WG * 1e6)+","+ num2str(Beta_ang);
    write(filename,Beta_ang_given_Lx);
}

plot(Lx_arr /um,beta_ang_array, "Lx (um)", "Angular propagation constant at 1550nm (rad/rad)");
