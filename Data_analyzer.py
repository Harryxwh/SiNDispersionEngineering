from Functions import *
from Coupled_Waveguides import *
from scipy.interpolate import CubicSpline
'''
class Data_analyzer:
To interpolate the propagation constant data, and calculate dispersion

Parameters:
wavl_arr            : unit: nm
gap_arr             : (gap_x,gap_y)     unit: um
filename_uncoupled  : filename of uncoupled modes data generated by class "Parameter Sweeper"
filename_coupled    : filename of coupled modes data generated by class "Parameter Sweeper"
param_filename      : filename of parameters, format: csv
plot_curve          : whether to plot the dispersion curve, default: True
num_of_pts          : num of points when interpolating the beta_coupled_arr, default: 100
'''

class Data_analyzer(Coupled_Waveguides):

    def __init__(self, wavl_arr, gap_arr,
                 filename_uncoupled, filename_coupled,
                 param_filename,
                 filename_result = "./results/AD_range_res.txt",
                 plot_curve = True,
                 Lumerical_data_exist = False,
                 filename_lumerical = "",
                 num_of_pts = 100):
        self.load_param(param_filename)
        self.wavl_arr = wavl_arr/1000   #unit: um
        self.wavl_arr_intp = np.linspace(np.min(self.wavl_arr),np.max(self.wavl_arr),num_of_pts)
        self.gap_arr = gap_arr
        self.plot_curve = plot_curve
        self.Lumerical_data_exist = Lumerical_data_exist
        self.num_of_pts = num_of_pts

        # beta_uncoupled_arr: shape = (?,4)   format: (wavl(unit:um),beta_WG1, beta_WG2, beta_ave(unit:rad/rad))
        self.beta_uncoupled_arr = self.Load_uncoupled_data(filename_uncoupled)
        # beta_coupled_arr:   shape = (?,3)   format: (wavl(unit:um),beta_supermode1, beta_supermode2(unit:rad/rad))
        self.beta_coupled_arr = self.Load_coupled_data_CMT(filename_coupled)
        if self.Lumerical_data_exist:
            self.beta_coupled_lumerical_arr, self.beta_ave_lumerical_arr = self.Load_coupled_data_Lumerical(filename_lumerical)

        gap_x, gap_y = self.gap_arr
        if gap_x > 0:
            self.bend_radius_outer = self.bend_radius_inner +\
                    gap_x + (self.WG1_width + self.WG2_width)/2       # unit :um
        else:
            self.bend_radius_outer = self.bend_radius_inner

        uncoupled_zero, AD_left_zero, AD_right_zero = self.Calc_Dispersion_curve(num_of_pts = self.num_of_pts)
        with open(filename_result,"a") as f:
            f.write("{:.2f}".format(gap_x) + ",{:.2f}".format(gap_y) +\
                    ",{:.6f}".format(uncoupled_zero) +\
                    ",{:.6f}".format(AD_left_zero) + ",{:.6f}".format(AD_right_zero)+"\n")

    def Load_uncoupled_data(self,filename_uncoupled):
        beta_uncoupled_arr = []
        with open(filename_uncoupled,'r') as f:
            data_uncoupled = f.readlines()
            for line in data_uncoupled[1:]:
                beta_uncoupled_arr.append(np.float64(line.split(",")))
        beta_uncoupled_arr = np.array(beta_uncoupled_arr)
        return beta_uncoupled_arr

    def Load_coupled_data_CMT(self, filename_coupled, wavl_idx = 10, print_coeffi = False):
        beta_coupled_arr = []
        coeff_supermode_1_arr = []
        coeff_supermode_2_arr = []
        with open(filename_coupled,'r') as f:
            data_coupled = f.readlines()
            for line in data_coupled[1:]:
                line = line.split(",")
                line_float = np.float64(line[:3])
                if line_float[1]<0:
                    beta_coupled = [line_float[0],line_float[2],line_float[1]]
                else:
                    beta_coupled = line_float[:3]
                assert len(beta_coupled) == 3
                assert len(line) == 7
                coeff_supermode_1 = [str2complex(line[3]),str2complex(line[4])]
                coeff_supermode_2 = [str2complex(line[5]),str2complex(line[6])]
                beta_coupled_arr.append(beta_coupled)
                coeff_supermode_1_arr.append(coeff_supermode_1)
                coeff_supermode_2_arr.append(coeff_supermode_2)
        beta_coupled_arr = np.array(beta_coupled_arr, dtype = np.float64)
        coeff_supermode_1_arr = np.array(coeff_supermode_1_arr, dtype = np.complex64)
        coeff_supermode_2_arr = np.array(coeff_supermode_2_arr, dtype = np.complex64)

        # coefficient of supermode at 1550nm
        if print_coeffi:
            print("wavelength = {:.2f}".format(beta_coupled_arr[wavl_idx,0]) + " um "\
                + "\nSupermode 1 coefficient : "  \
                + 'A = ({0.real:.6f} + {0.imag:.6f}i)'.format(coeff_supermode_1_arr[wavl_idx,0]) + ', '\
                + 'B = ({0.real:.6f} + {0.imag:.6f}i)'.format(coeff_supermode_1_arr[wavl_idx,1])\
                + "\nSupermode 2 coefficient : "  \
                + 'A = ({0.real:.6f} + {0.imag:.6f}i)'.format(coeff_supermode_2_arr[wavl_idx,0]) + ', '\
                + 'B = ({0.real:.6f} + {0.imag:.6f}i)'.format(coeff_supermode_2_arr[wavl_idx,1]))

        return beta_coupled_arr

    def Load_coupled_data_Lumerical(self, filename_lumerical):
        beta_coupled_lumerical_arr_ori = []
        with open(filename_lumerical,'r') as f:
            data_lumerical = f.readlines()
            beta_ang_mode1 = 0
            for line in data_lumerical[2:]:
                wavelength  = float(line.split(',')[0])/1000 #unit:um
                modeidx     = int(line.split(',')[1])
                neff        = str2complex(line.split(',')[2])
                ng          = str2complex(line.split(',')[3])
                loss        = float(line.split(',')[4])
                polarization= float(line.split(',')[5])
                beta_ang    = float(line.split(',')[6])

                if modeidx == 1:
                    # Mode 1
                    beta_ang_mode1 = beta_ang
                else:
                    # Mode 2
                    beta_ang_mode2 = beta_ang
                    beta_coupled_lumerical_arr_ori.append([wavelength,beta_ang_mode1,beta_ang_mode2])

        beta_coupled_lumerical_arr_ori = np.array(beta_coupled_lumerical_arr_ori)
        # beta_ave = beta_uncoupled_arr[:,3]
        beta_ave_arr = (beta_coupled_lumerical_arr_ori[:,1] + beta_coupled_lumerical_arr_ori[:,2])/2
        beta_coupled_lumerical_arr = np.copy(beta_coupled_lumerical_arr_ori)
        beta_coupled_lumerical_arr[:,1] = beta_coupled_lumerical_arr_ori[:,1] - beta_ave_arr
        beta_coupled_lumerical_arr[:,2] = beta_coupled_lumerical_arr_ori[:,2] - beta_ave_arr
        return beta_coupled_lumerical_arr, beta_ave_arr

    def Plot_curve(self,data_arr,Y_legends,
                    X_label,Y_label,title,
                    marker_list,linestyle_list,
                    colors_list=['green','mediumblue','tomato','orange',
                                 'tomato','orange','deepskyblue','lightskyblue']*2,
                    bbox_to_anchor=(),text="",dpi=400,plot_show=False):
            #Plot parameters
            figsize = (8,6)
            fonttype = "Helvetica"
            fontsize = 9
            grid_linewidth = 0.8
            plot_linewidth = 1.5

            plt.figure(figsize=figsize)
            idx = 0
            for data_idx in range(len(data_arr)):
                X       = data_arr[data_idx][:,0]           #X is a 2D array
                Y_arr   = data_arr[data_idx][:,1:]          #Y_arr is a 2D array
                for Y_idx in range(np.shape(Y_arr)[1]):
                    plt.plot(X,Y_arr[:,Y_idx],label=Y_legends[idx],
                                color=colors_list[idx], marker=marker_list[idx],
                                linestyle=linestyle_list[idx], linewidth=plot_linewidth)
                    idx = idx + 1

            plt.rcParams["font.family"] = fonttype
            plt.rcParams.update({'font.size': fontsize})
            plt.yticks(fontproperties = fonttype, size = fontsize)
            plt.xticks(fontproperties = fonttype, size = fontsize)
            plt.ylabel(Y_label, fontdict={'family' : fonttype, 'size' : fontsize})
            plt.xlabel(X_label, fontdict={'family' : fonttype, 'size' : fontsize})
            plt.title(title)
            if len(bbox_to_anchor)>0:
                plt.legend(bbox_to_anchor=bbox_to_anchor, loc='lower left', borderaxespad=0)
            else:
                plt.legend(loc='best')
            if not text == "":
                plt.text(np.quantile(X,0.5),np.quantile(Y_arr,0.01),
                        text, bbox=dict(boxstyle="round,pad=0.9", fc="white", alpha=0.9))
            plt.grid(linewidth=grid_linewidth, alpha=0.3)
            savename = "results/"+str(title)+".jpg"
            plt.savefig(savename,dpi=dpi)
            plt.tight_layout()
            # if plot_show:
            #     plt.show()

    def Polynomial_fit(self,x, y_arr, x_fit, order = 1, num_of_fit_pts  = 100):
        num_of_columns  = np.shape(y_arr)[1]
        coeffi_array    = np.zeros((order+1,num_of_columns))
        y_fit_arr       = np.zeros((num_of_fit_pts,num_of_columns))
        for idx in range(num_of_columns):
            y = y_arr[:,idx]
            coefficients = np.polyfit(x, y, order)
            coeffi_array[:,idx] = coefficients
            y_fit = np.polyval(coefficients, x_fit)
            y_fit_arr[:,idx] = y_fit

        return coeffi_array, y_fit_arr

    def Interpolation(self,x,y,x_intp,num_of_pts=100):
        cs = CubicSpline(x, y, bc_type='natural')  # bc_type 可选 'natural', 'clamped', 'periodic' 等
        y_intp = cs(x_intp)
        return y_intp

    def Anomalous_D_bandwidth(self,wavl_arr,beta_supermode):
        start_idx = int(len(beta_supermode)/2)
        start_idx = np.argmax(beta_supermode)
        left_zero = wavl_arr[start_idx]
        right_zero = wavl_arr[start_idx]
        left_found = False
        right_found = False
        for delta_idx in range(int(len(beta_supermode)/2)):
            if (not right_found) and (start_idx + delta_idx < len(beta_supermode)-1):
                idx = start_idx + delta_idx
                if beta_supermode[idx] > 0 and beta_supermode[idx+1] < 0:
                    right_zero =  wavl_arr[idx] + (wavl_arr[idx+1]-wavl_arr[idx])*\
                            beta_supermode[idx]/(beta_supermode[idx]-beta_supermode[idx+1])
                    right_found = True
                    # print("Right Found, wavl:" + str(wavl_arr[idx]) + ", beta =" + str(beta_supermode[idx]))
                elif  beta_supermode[idx+1] > 0:
                    right_zero = wavl_arr[idx+1]

            if (not left_found) and (start_idx - delta_idx > 0):
                idx = start_idx - delta_idx
                if beta_supermode[idx] > 0 and beta_supermode[idx-1] < 0:
                    left_zero =  wavl_arr[idx] + (wavl_arr[idx-1]-wavl_arr[idx])*\
                            beta_supermode[idx]/(beta_supermode[idx]-beta_supermode[idx-1])
                    left_found = True
                    # print("Left Found, wavl:" + str(wavl_arr[idx]) + ", beta =" + str(beta_supermode[idx]))
                elif  beta_supermode[idx-1] > 0:
                    left_zero = wavl_arr[idx-1]

        return (left_zero*1e3,right_zero*1e3)   # nm

    # Beta      : unit: rad/m
    # wavl_arr  : unit: um
    def Calculate_dispersion_D(self,Beta,wavl_arr_):

        wavl_arr    = wavl_arr_ * 1e-6
        fre_arr     = 3*10**8 / (wavl_arr)
        Beta_1      = First_derivative_central_diff(Beta, fre_arr)
        Beta_1      = Beta_1 *10**(12) * 10**(3)        # unit: ps/km
        D           = First_derivative_central_diff(Beta_1, wavl_arr[1:-1])
        D           = D * 10**(-9)                          # unit: ps/km/nm
        return D, Beta_1

    # Interpolate the propagation constant curve and calc the dispersion profile
    def Calc_Dispersion_curve(self,num_of_pts = 100):

        # unit: m
        R_WG1       = self.bend_radius_inner / 1e6
        R_WG2       = self.bend_radius_outer / 1e6
        R_ave       = (R_WG1+R_WG2)/2

        # Interpolate the propagation constant data
        self.beta_coupled_arr_intp  = self.Interpolation(self.wavl_arr,
                                                self.beta_coupled_arr[:,1:],
                                                self.wavl_arr_intp,num_of_pts)
        coeffi_array, self.beta_uncoupled_arr_intp = self.Polynomial_fit(self.wavl_arr,
                                                        self.beta_uncoupled_arr[:,1:],
                                                        self.wavl_arr_intp,
                                                        2, num_of_pts)
        # Dispersion of Isolated WGs
        beta_uncoupled_WG1 = (self.beta_uncoupled_arr[:,1]+self.beta_uncoupled_arr[:,3])  / R_WG1     # unit: rad/m
        beta_uncoupled_WG2 = (self.beta_uncoupled_arr[:,2]+self.beta_uncoupled_arr[:,3])  / R_WG2     # unit: rad/m

        beta_uncoupled_WG1_intp = (self.beta_uncoupled_arr_intp[:,0]+
                                self.beta_uncoupled_arr_intp[:,2])  / R_WG1     # unit: rad/m
        beta_uncoupled_WG2_intp = (self.beta_uncoupled_arr_intp[:,1]+
                                self.beta_uncoupled_arr_intp[:,2])  / R_WG2     # unit: rad/m


        D_WG1, Beta_1_WG1 = self.Calculate_dispersion_D(beta_uncoupled_WG1,self.wavl_arr)
        D_WG1_intp, Beta_1_WG1_intp = self.Calculate_dispersion_D(beta_uncoupled_WG1_intp,self.wavl_arr_intp)
        D_WG2, Beta_1_WG2 = self.Calculate_dispersion_D(beta_uncoupled_WG2,self.wavl_arr)
        D_WG2_intp, Beta_1_WG2_intp= self.Calculate_dispersion_D(beta_uncoupled_WG2_intp,self.wavl_arr_intp)

        uncoupled_zero_arr, uncoupled_zero_idx = find_zero(self.wavl_arr_intp[2:-2]*1e3,
                                                           (D_WG1_intp + D_WG2_intp)/2)
        if len(uncoupled_zero_arr)>0:
            uncoupled_zero = uncoupled_zero_arr[0]      # unit:nm
        else:
            uncoupled_zero = 0

        # Dispersion of coupled WGs using CMT
        beta_CMT_supermode1      = (self.beta_coupled_arr[:,1] +
                                    self.beta_uncoupled_arr[:,3])  / R_ave         # unit: rad/m
        beta_CMT_supermode2      = (self.beta_coupled_arr[:,2] +
                                    self.beta_uncoupled_arr[:,3])  / R_ave         # unit: rad/m
        beta_CMT_supermode1_intp = (self.beta_coupled_arr_intp[:,0] +
                                    self.beta_uncoupled_arr_intp[:,2])  / R_ave    # unit: rad/m
        beta_CMT_supermode2_intp = (self.beta_coupled_arr_intp[:,1] +
                                    self.beta_uncoupled_arr_intp[:,2])  / R_ave    # unit: rad/m

        D_supermode_1, Beta_1_supermode_1 = self.Calculate_dispersion_D(beta_CMT_supermode1,self.wavl_arr)
        D_supermode_2, Beta_1_supermode_2 = self.Calculate_dispersion_D(beta_CMT_supermode2,self.wavl_arr)
        D_supermode_1_intp, Beta_1_supermode_1_intp = self.Calculate_dispersion_D(beta_CMT_supermode1_intp,self.wavl_arr_intp)
        D_supermode_2_intp, Beta_1_supermode_2_intp = self.Calculate_dispersion_D(beta_CMT_supermode2_intp,self.wavl_arr_intp)

        Y_data = (np.c_[self.wavl_arr,
                        self.beta_uncoupled_arr[:,1:3],
                        self.beta_coupled_arr[:,1:]],
                  np.c_[self.wavl_arr_intp,
                        self.beta_coupled_arr_intp[:,:]],)
        if self.Lumerical_data_exist:
            Y_data = Y_data + (self.beta_coupled_lumerical_arr,)



        # Plot propagation const curve
        if self.plot_curve:
            Plot_curve(Y_data,
                        Y_legends=['Uncoupled inner ring','Uncoupled outer ring',
                                'Supermode 1 (CMT)','Supermode 2 (CMT)',
                                'Supermode 1 (CMT) Interpolation','Supermode 2 (CMT) Interpolation',
                                'Supermode 1 (FDE)','Supermode 2 (FDE)',
                                'beta_iso_inner','beta_iso_outer'],
                        X_label='wavelength(um)',
                        Y_label=r'$ \tilde{\beta}$ - $\bar{\beta}$(rad/rad)',
                        title = r"Propagation constant of coupled modes calculated using different methods",
                        marker_list=["","",".",".","","","o","o"],
                        linestyle_list=["--","--","","","-","-","",""],
                        colors_list=['green','mediumblue','tomato','orange',
                                 'tomato','orange','deepskyblue','lightskyblue']*2)

        # Wavelength range of anomalous dispersion (unit: nm)
        AD_left_zero,AD_right_zero = self.Anomalous_D_bandwidth(self.wavl_arr_intp[2:-2], D_supermode_2_intp)

        AD_range_text = "AD range = " + "{:.2f} nm".format(AD_left_zero)\
                        + " - {:.2f} nm".format(AD_right_zero)

        Y_data = (np.c_[ self.wavl_arr_intp[2:-2],
                        D_WG1_intp, D_WG2_intp,
                        D_supermode_1_intp, D_supermode_2_intp],)

        # Dispersion of coupled WGs using FDE (if exist)
        if self.Lumerical_data_exist:
            wavl_arr_lumerical = self.beta_coupled_lumerical_arr[:,0]    # unit: um
            wavl_arr_lumerical_intp = np.linspace(np.min(wavl_arr_lumerical),
                                                  np.max(wavl_arr_lumerical),
                                                  num_of_pts)
            # Interpolating beta_ave in the range of wavl_arr_lumerical
            wavl_arr_lumerical_mask = np.where((self.wavl_arr >= np.min(wavl_arr_lumerical))\
                                            & (self.wavl_arr <= np.max(wavl_arr_lumerical)))
            coeffi_array, beta_ave_intp =  self.Polynomial_fit(wavl_arr_lumerical,
                                        self.beta_ave_lumerical_arr.reshape(-1,1),
                                        wavl_arr_lumerical_intp, order=2, num_of_fit_pts=num_of_pts)
            # plt.figure()
            # plt.plot(wavl_arr_lumerical_intp,beta_ave_intp,marker = "")
            # plt.plot(wavl_arr_lumerical,
            #          self.beta_ave_lumerical_arr.reshape(-1,1),
            #          marker = "o")
            beta_coupled_lumerical_arr_intp  = self.Interpolation(wavl_arr_lumerical,
                                                self.beta_coupled_lumerical_arr[:,1:],
                                                wavl_arr_lumerical_intp,num_of_pts)
            beta_coupled_lumerical_arr_intp += \
                beta_ave_intp.reshape(-1,1) # adding beta_ave
            beta_coupled_lumerical_arr_intp = \
                beta_coupled_lumerical_arr_intp / R_ave   # now unit: 1/m

            D_lumerical_supermode_1_intp, Beta_1_lumerical_supermode_1_intp = self.Calculate_dispersion_D(beta_coupled_lumerical_arr_intp[:,0],wavl_arr_lumerical_intp)
            D_lumerical_supermode_2_intp, Beta_1_lumerical_supermode_2_intp = self.Calculate_dispersion_D(beta_coupled_lumerical_arr_intp[:,1],wavl_arr_lumerical_intp)

            Y_data = Y_data + (np.c_[wavl_arr_lumerical_intp[2:-2],
                      D_lumerical_supermode_1_intp,D_lumerical_supermode_2_intp],)

        gap_info = "gap_"+"{:.1f}".format(self.gap_arr[0])+\
                    ","+"{:.1f}".format(self.gap_arr[1])
        gap_info = gap_info.replace(".","_")


        # Plot dispersion curve
        if self.plot_curve:
            Plot_curve(Y_data,
                    Y_legends=['Inner Ring','Outer Ring',
                            'Supermode 1 (CMT)','Supermode 2 (CMT)',
                            'Supermode 1 (FDE)','Supermode 2 (FDE)']*2,
                    X_label=r'wavelength($\mu m$)',Y_label=r'$D(ps/nm/km)$',
                    title = "Dispersion of coupled modes"+gap_info,
                    marker_list=["","","","","",""]*2,
                    linestyle_list=["--","--","-","-","-","-","-","-"]*2,
                    colors_list=['green','mediumblue','tomato','orange',
                                 'tomato','orange','deepskyblue','lightskyblue']*2,
                    text=AD_range_text)
        return uncoupled_zero, AD_left_zero, AD_right_zero

