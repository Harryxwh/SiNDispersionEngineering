import pandas as pd
import os
from Functions import *
from Coupled_Waveguides import *
from scipy.interpolate import CubicSpline
'''
class Data_analyzer:
To interpolate the propagation constant data, and calculate dispersion

Parameters:
wavl_arr            : unit: nm
gap_arr             : (gap_x,gap_y)     unit: um
filename_uncoupled  : filename of uncoupled modes data generated by class "Parameter Sweeper"
filename_coupled    : filename of coupled modes data generated by class "Parameter Sweeper"
param_filename      : filename of parameters, format: csv
plot_curve          : whether to plot the dispersion curve, default: True
num_of_pts          : num of points when interpolating the beta_coupled_arr, default: 100
'''

class Data_analyzer(Coupled_Waveguides):

    def __init__(self, wavl_arr, gap_arr,
                 filename_uncoupled, filename_coupled,
                 param_filename,
                 filename_result = "./results/AD_range_res.txt",
                 plot_curve = True,
                 Lumerical_data_exist = False,
                 filename_lumerical = "",
                 num_of_pts = 100):
        self.load_param(param_filename)
        self.num_of_pts = num_of_pts
        self.wavl_arr = wavl_arr/1000   #unit: um
        self.wavl_arr_intp = np.linspace(np.min(self.wavl_arr),np.max(self.wavl_arr),
                                         self.num_of_pts)  #unit: um
        self.gap_arr = gap_arr
        self.plot_curve = plot_curve
        self.Lumerical_data_exist = Lumerical_data_exist

        # beta_uncoupled_arr: shape = (?,4)   format: (wavl(unit:um),beta_WG1, beta_WG2, beta_ave(unit:rad/rad))
        self.beta_uncoupled_arr = self.Load_uncoupled_data(filename_uncoupled)
        # beta_coupled_arr:   shape = (?,3)   format: (wavl(unit:um),beta_supermode1, beta_supermode2(unit:rad/rad))
        self.beta_coupled_arr = self.Load_coupled_data_CMT(filename_coupled)
        if self.Lumerical_data_exist:
            self.beta_coupled_lumerical_arr, self.beta_ave_lumerical_arr = self.Load_coupled_data_Lumerical(filename_lumerical)

        gap_x, gap_y = self.gap_arr
        if gap_x > 0:
            self.bend_radius_outer = self.bend_radius_inner +\
                    gap_x + (self.WG1_width + self.WG2_width)/2       # unit :um
        else:
            self.bend_radius_outer = self.bend_radius_inner

        self.Calc_Dispersion_curve(num_of_pts = self.num_of_pts)


    def Load_uncoupled_data(self,filename_uncoupled):
        beta_uncoupled_arr = []
        with open(filename_uncoupled,'r') as f:
            data_uncoupled = f.readlines()
            for line in data_uncoupled[1:]:
                beta_uncoupled_arr.append(np.float64(line.split(",")))
        beta_uncoupled_arr = np.array(beta_uncoupled_arr)
        return beta_uncoupled_arr

    def Load_coupled_data_CMT(self, filename_coupled, wavl_idx = 10, print_coeffi = False):
        beta_coupled_arr = []
        coeff_supermode_1_arr = []
        coeff_supermode_2_arr = []
        with open(filename_coupled,'r') as f:
            data_coupled = f.readlines()
            for line in data_coupled[1:]:
                line = line.split(",")
                line_float = np.float64(line[:3])
                if line_float[1]<0:
                    beta_coupled = [line_float[0],line_float[2],line_float[1]]
                else:
                    beta_coupled = line_float[:3]
                assert len(beta_coupled) == 3
                assert len(line) == 7
                coeff_supermode_1 = [str2complex(line[3]),str2complex(line[4])]
                coeff_supermode_2 = [str2complex(line[5]),str2complex(line[6])]
                beta_coupled_arr.append(beta_coupled)
                coeff_supermode_1_arr.append(coeff_supermode_1)
                coeff_supermode_2_arr.append(coeff_supermode_2)
        beta_coupled_arr = np.array(beta_coupled_arr, dtype = np.float64)
        coeff_supermode_1_arr = np.array(coeff_supermode_1_arr, dtype = np.complex64)
        coeff_supermode_2_arr = np.array(coeff_supermode_2_arr, dtype = np.complex64)

        # coefficient of supermode at 1550nm
        if print_coeffi:
            print("wavelength = {:.2f}".format(beta_coupled_arr[wavl_idx,0]) + " um "\
                + "\nSupermode 1 coefficient : "  \
                + 'A = ({0.real:.6f} + {0.imag:.6f}i)'.format(coeff_supermode_1_arr[wavl_idx,0]) + ', '\
                + 'B = ({0.real:.6f} + {0.imag:.6f}i)'.format(coeff_supermode_1_arr[wavl_idx,1])\
                + "\nSupermode 2 coefficient : "  \
                + 'A = ({0.real:.6f} + {0.imag:.6f}i)'.format(coeff_supermode_2_arr[wavl_idx,0]) + ', '\
                + 'B = ({0.real:.6f} + {0.imag:.6f}i)'.format(coeff_supermode_2_arr[wavl_idx,1]))

        return beta_coupled_arr

    def Load_coupled_data_Lumerical(self, filename_lumerical):
        beta_coupled_lumerical_arr_ori = []
        with open(filename_lumerical,'r') as f:
            data_lumerical = f.readlines()
            beta_ang_mode1 = 0
            for line in data_lumerical[2:]:
                wavelength  = float(line.split(',')[0])/1000 #unit:um
                modeidx     = int(line.split(',')[1])
                neff        = str2complex(line.split(',')[2])
                ng          = str2complex(line.split(',')[3])
                loss        = float(line.split(',')[4])
                polarization= float(line.split(',')[5])
                beta_ang    = float(line.split(',')[6])

                if modeidx == 1:
                    # Mode 1
                    beta_ang_mode1 = beta_ang
                else:
                    # Mode 2
                    beta_ang_mode2 = beta_ang
                    beta_coupled_lumerical_arr_ori.append([wavelength,beta_ang_mode1,beta_ang_mode2])

        beta_coupled_lumerical_arr_ori = np.array(beta_coupled_lumerical_arr_ori)
        # beta_ave = beta_uncoupled_arr[:,3]
        beta_ave_arr = (beta_coupled_lumerical_arr_ori[:,1] + beta_coupled_lumerical_arr_ori[:,2])/2
        beta_coupled_lumerical_arr = np.copy(beta_coupled_lumerical_arr_ori)
        beta_coupled_lumerical_arr[:,1] = beta_coupled_lumerical_arr_ori[:,1] - beta_ave_arr
        beta_coupled_lumerical_arr[:,2] = beta_coupled_lumerical_arr_ori[:,2] - beta_ave_arr
        return beta_coupled_lumerical_arr, beta_ave_arr

    def Polynomial_fit(self,x, y_arr, x_fit, order = 1, num_of_fit_pts  = 100):
        num_of_columns  = np.shape(y_arr)[1]
        coeffi_array    = np.zeros((order+1,num_of_columns))
        y_fit_arr       = np.zeros((num_of_fit_pts,num_of_columns))
        for idx in range(num_of_columns):
            y = y_arr[:,idx]
            coefficients = np.polyfit(x, y, order)
            coeffi_array[:,idx] = coefficients
            y_fit = np.polyval(coefficients, x_fit)
            y_fit_arr[:,idx] = y_fit

        return coeffi_array, y_fit_arr

    def Interpolation(self,x,y,x_intp,num_of_pts=100):
        cs = CubicSpline(x, y, bc_type='natural')  # bc_type 可选 'natural', 'clamped', 'periodic' 等
        y_intp = cs(x_intp)
        return y_intp

    def Anomalous_D_bandwidth(self,wavl_arr,beta_supermode):
        start_idx = int(len(beta_supermode)/2)
        start_idx = np.argmax(beta_supermode)
        left_zero = wavl_arr[start_idx]
        right_zero = wavl_arr[start_idx]
        left_found = False
        right_found = False
        for delta_idx in range(int(len(beta_supermode)/2)):
            if (not right_found) and (start_idx + delta_idx < len(beta_supermode)-1):
                idx = start_idx + delta_idx
                if beta_supermode[idx] > 0 and beta_supermode[idx+1] < 0:
                    right_zero =  wavl_arr[idx] + (wavl_arr[idx+1]-wavl_arr[idx])*\
                            beta_supermode[idx]/(beta_supermode[idx]-beta_supermode[idx+1])
                    right_found = True
                    # print("Right Found, wavl:" + str(wavl_arr[idx]) + ", beta =" + str(beta_supermode[idx]))
                elif  beta_supermode[idx+1] > 0:
                    right_zero = wavl_arr[idx+1]

            if (not left_found) and (start_idx - delta_idx > 0):
                idx = start_idx - delta_idx
                if beta_supermode[idx] > 0 and beta_supermode[idx-1] < 0:
                    left_zero =  wavl_arr[idx] + (wavl_arr[idx-1]-wavl_arr[idx])*\
                            beta_supermode[idx]/(beta_supermode[idx]-beta_supermode[idx-1])
                    left_found = True
                    # print("Left Found, wavl:" + str(wavl_arr[idx]) + ", beta =" + str(beta_supermode[idx]))
                elif  beta_supermode[idx-1] > 0:
                    left_zero = wavl_arr[idx-1]

        return (left_zero*1e3,right_zero*1e3)   # nm

    # Beta      : unit: rad/m
    # wavl_arr  : unit: um
    def Calculate_dispersion_D(self,Beta,wavl_arr_):

        wavl_arr    = wavl_arr_ * 1e-6
        fre_arr     = 3*10**8 / (wavl_arr)
        Beta_1      = First_derivative_central_diff(Beta, fre_arr)
        Beta_1      = Beta_1 *10**(12) * 10**(3)        # unit: ps/km
        D           = First_derivative_central_diff(Beta_1, wavl_arr[1:-1])
        D           = D * 10**(-9)                          # unit: ps/km/nm
        return D, Beta_1

    def write_csv(self, gap, wavl_arr, D_WG, D_supermode,
                  filename_D_iso, filename_D_supermode):

        if not os.path.exists(filename_D_iso):
            df_iso = pd.DataFrame()
            df_iso['wavl'] = wavl_arr
        else:
            df_iso = pd.read_csv(filename_D_iso)
        df_iso[gap] = D_WG
        df_iso.to_csv(filename_D_iso, index=False, encoding="utf-8")

        if not os.path.exists(filename_D_supermode):
            df_coupled = pd.DataFrame()
            df_coupled['wavl'] = wavl_arr
        else:
            df_coupled = pd.read_csv(filename_D_supermode)
        df_coupled[gap] = D_supermode
        df_coupled.to_csv(filename_D_supermode, index=False, encoding="utf-8")

    def calc_Dispersion_using_data_from_FDE(self,wavl_arr_lumerical,
                                            wavl_arr_lumerical_intp):
        # Interpolating beta_ave in the range of wavl_arr_lumerical
        wavl_arr_lumerical_mask = np.where((self.wavl_arr >= np.min(wavl_arr_lumerical))\
                                        & (self.wavl_arr <= np.max(wavl_arr_lumerical)))
        coeffi_array, beta_ave_intp =  self.Polynomial_fit(wavl_arr_lumerical,
                                    self.beta_ave_lumerical_arr.reshape(-1,1),
                                    wavl_arr_lumerical_intp, order=2, num_of_fit_pts=num_of_pts)

        beta_coupled_lumerical_arr_intp  = self.Interpolation(wavl_arr_lumerical,
                                            self.beta_coupled_lumerical_arr[:,1:],
                                            wavl_arr_lumerical_intp,num_of_pts)
        beta_coupled_lumerical_arr_intp += \
            beta_ave_intp.reshape(-1,1) # adding beta_ave
        beta_coupled_lumerical_arr_intp = \
            beta_coupled_lumerical_arr_intp / R_ave   # now unit: 1/m

        D_lumerical_supermode_1_intp, Beta_1_lumerical_supermode_1_intp = self.Calculate_dispersion_D(beta_coupled_lumerical_arr_intp[:,0],wavl_arr_lumerical_intp)
        D_lumerical_supermode_2_intp, Beta_1_lumerical_supermode_2_intp = self.Calculate_dispersion_D(beta_coupled_lumerical_arr_intp[:,1],wavl_arr_lumerical_intp)
        return D_lumerical_supermode_1_intp,_lumerical_supermode_2_intp

    # Interpolate the propagation constant curve and calc the dispersion profile
    def Calc_Dispersion_curve(self,num_of_pts = 100):

        # unit: m
        R_WG1       = self.bend_radius_inner / 1e6
        R_WG2       = self.bend_radius_outer / 1e6
        R_ave       = (R_WG1+R_WG2)/2

        # Interpolate the propagation constant data
        self.beta_coupled_arr_intp  = self.Interpolation(self.wavl_arr,
                                                self.beta_coupled_arr[:,1:],
                                                self.wavl_arr_intp,num_of_pts)
        coeffi_array, self.beta_uncoupled_arr_intp = self.Polynomial_fit(self.wavl_arr,
                                                        self.beta_uncoupled_arr[:,1:],
                                                        self.wavl_arr_intp,
                                                        2, num_of_pts)
        # Dispersion of Isolated WGs
        beta_uncoupled_WG1 = (self.beta_uncoupled_arr[:,1]+self.beta_uncoupled_arr[:,3])  / R_WG1     # unit: rad/m
        beta_uncoupled_WG2 = (self.beta_uncoupled_arr[:,2]+self.beta_uncoupled_arr[:,3])  / R_WG2     # unit: rad/m

        beta_uncoupled_WG1_intp = (self.beta_uncoupled_arr_intp[:,0]+
                                self.beta_uncoupled_arr_intp[:,2])  / R_WG1     # unit: rad/m
        beta_uncoupled_WG2_intp = (self.beta_uncoupled_arr_intp[:,1]+
                                self.beta_uncoupled_arr_intp[:,2])  / R_WG2     # unit: rad/m

        D_WG1, Beta_1_WG1 = self.Calculate_dispersion_D(beta_uncoupled_WG1,self.wavl_arr)
        D_WG1_intp, Beta_1_WG1_intp = self.Calculate_dispersion_D(beta_uncoupled_WG1_intp,self.wavl_arr_intp)
        D_WG2, Beta_1_WG2 = self.Calculate_dispersion_D(beta_uncoupled_WG2,self.wavl_arr)
        D_WG2_intp, Beta_1_WG2_intp= self.Calculate_dispersion_D(beta_uncoupled_WG2_intp,self.wavl_arr_intp)

        # Dispersion of coupled WGs using CMT
        beta_CMT_supermode1      = (self.beta_coupled_arr[:,1] +
                                    self.beta_uncoupled_arr[:,3])  / R_ave         # unit: rad/m
        beta_CMT_supermode2      = (self.beta_coupled_arr[:,2] +
                                    self.beta_uncoupled_arr[:,3])  / R_ave         # unit: rad/m
        beta_CMT_supermode1_intp = (self.beta_coupled_arr_intp[:,0] +
                                    self.beta_uncoupled_arr_intp[:,2])  / R_ave    # unit: rad/m
        beta_CMT_supermode2_intp = (self.beta_coupled_arr_intp[:,1] +
                                    self.beta_uncoupled_arr_intp[:,2])  / R_ave    # unit: rad/m

        D_supermode_1, Beta_1_supermode_1 = self.Calculate_dispersion_D(beta_CMT_supermode1,self.wavl_arr)
        D_supermode_2, Beta_1_supermode_2 = self.Calculate_dispersion_D(beta_CMT_supermode2,self.wavl_arr)
        D_supermode_1_intp, Beta_1_supermode_1_intp = self.Calculate_dispersion_D(beta_CMT_supermode1_intp,self.wavl_arr_intp)
        D_supermode_2_intp, Beta_1_supermode_2_intp = self.Calculate_dispersion_D(beta_CMT_supermode2_intp,self.wavl_arr_intp)

        Y_data = (np.c_[self.wavl_arr,
                        self.beta_uncoupled_arr[:,1:3],
                        self.beta_coupled_arr[:,1:]],
                  np.c_[self.wavl_arr_intp,
                        self.beta_coupled_arr_intp[:,:]],)
        if self.Lumerical_data_exist:
            Y_data = Y_data + (self.beta_coupled_lumerical_arr,)

        gap_info = "gap_"+"{:.2f}".format(self.gap_arr[0])+\
                    ","+"{:.2f}".format(self.gap_arr[1])
        gap_info = gap_info.replace(".","_")

        # Plot propagation const curve
        if self.plot_curve:
            Plot_curve(Y_data,
                        Y_legends=['Uncoupled inner ring','Uncoupled outer ring',
                                'Supermode 1 (CMT)','Supermode 2 (CMT)',
                                'Supermode 1 (CMT) Interpolation','Supermode 2 (CMT) Interpolation',
                                'Supermode 1 (FDE)','Supermode 2 (FDE)',
                                'beta_iso_inner','beta_iso_outer'],
                        X_label='wavelength(um)',
                        Y_label=r'$ \tilde{\beta}$ - $\bar{\beta}$(rad/rad)',
                        title = r"Propagation constant of coupled modes calculated using different methods",
                        marker_list=["","",".",".","","","o","o"],
                        linestyle_list=["--","--","","","-","-","",""],
                        colors_list=['green','mediumblue','tomato','orange',
                                 'tomato','orange','deepskyblue','lightskyblue']*2)

        Y_data = (np.c_[ self.wavl_arr_intp[2:-2],
                        D_WG1_intp, D_WG2_intp,
                        D_supermode_1_intp, D_supermode_2_intp],)

        # Dispersion of coupled WGs using FDE (if exist)
        if self.Lumerical_data_exist:
            wavl_arr_lumerical = self.beta_coupled_lumerical_arr[:,0]    # unit: um
            wavl_arr_lumerical_intp = np.linspace(np.min(wavl_arr_lumerical),
                                                np.max(wavl_arr_lumerical),
                                                num_of_pts)
            D_lumerical_supermode_1_intp, D_lumerical_supermode_2_intp =self.calc_Dispersion_using_data_from_FDE(wavl_arr_lumerical, wavl_arr_lumerical_intp)
            Y_data = Y_data + (np.c_[wavl_arr_lumerical_intp[2:-2],
                      D_lumerical_supermode_1_intp,D_lumerical_supermode_2_intp],)

        # Plot dispersion curve
        if self.plot_curve:
            Plot_curve(Y_data,
                    Y_legends=['Inner Ring','Outer Ring',
                            'Supermode 1 (CMT)','Supermode 2 (CMT)',
                            'Supermode 1 (FDE)','Supermode 2 (FDE)']*2,
                    X_label=r'wavelength($\mu m$)',Y_label=r'$D(ps/nm/km)$',
                    title = "Dispersion of coupled modes"+gap_info,
                    marker_list=["","","","","",""]*2,
                    linestyle_list=["--","--","-","-","-","-","-","-"]*2,
                    colors_list=['green','mediumblue','tomato','orange',
                                 'tomato','orange','deepskyblue','lightskyblue']*2,
                    text="")

        gap_label = "({:.2f}".format(self.gap_arr[0])+\
                    ","+"{:.2f})".format(self.gap_arr[1])
        D_WG_ave = (D_WG1_intp+D_WG2_intp)/2

        self.write_csv(gap= gap_label, wavl_arr= self.wavl_arr_intp[2:-2],
                    D_WG=D_WG_ave, D_supermode=D_supermode_2_intp,
                    filename_D_iso="./results/Dispersion_isolated_WG.csv",
                    filename_D_supermode="./results/Dispersion_coupled_WG.csv")

