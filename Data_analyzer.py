import pandas as pd
import os
import re
from Functions import *
from Coupled_Waveguides import *
from scipy.interpolate import CubicSpline
'''
class Data_analyzer:
This class is used to analyze the data generated by the Parameter Sweeper class.
It can load the data of the uncoupled and coupled modes, calculate the dispersion curve.
It can also load the data of the FDE calculated modes and compare the results.
The results are saved in a csv file and can be also plotted.

Parameters:
-------------------------------------------------------------------------------------
Compulsory:
wavl_arr            : array of wavlengths   (unit: nm)
gap_arr             : (gap_x,gap_y). gap between the two WGs in x or y direction   (unit: um)
param_filename      : filename of parameters, format: csv
filename_uncoupled  : filename of uncoupled modes data generated by class "Parameter Sweeper"
filename_coupled    : filename of coupled modes data generated by class "Parameter Sweeper"
num_of_pts          : num of points when interpolating the beta arr, default: 100
-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------
FDE data to compare with (optional):
filename_FDE_beta   : filename of FDE calculated beta data. if "", not loaded.
filename_FDE_beta   : filename of FDE calculated Dispersion data. if "", not loaded.
-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------
Plot and save options:
plot_curve          : whether to plot the dispersion curve, default: True
save_D_in_csv       : whether to save the calculated dispersion curve as a csv, default: True
save_mode           : to save the dispersion of which supermode, "AS" (anti-symmetric) or "S" (symmetric). "AS" by default
filename_coeffi     : filename to save the coefficients of the supermodes. if "", not saved.
-------------------------------------------------------------------------------------

Author: Weihao Xu
Date: May. 8th, 2025
'''

class Data_analyzer(Coupled_Waveguides):

    def __init__(self, wavl_arr, gap_arr, param_filename,
                 filename_uncoupled, filename_coupled, num_of_pts = 100,
                 filename_FDE_beta = "", filename_FDE_D = "",
                 plot_curve = True, save_D_in_csv = True, save_mode = "AS", filename_coeffi = "",
                ):

        self.load_param(param_filename)
        self.num_of_pts = num_of_pts
        self.wavl_arr = wavl_arr/1000                       #unit: um
        self.wavl_arr_intp = np.linspace(np.min(self.wavl_arr),np.max(self.wavl_arr),
                                         self.num_of_pts)   #unit: um
        self.gap_arr = gap_arr
        self.plot_curve = plot_curve
        self.save_D_in_csv = save_D_in_csv
        self.save_mode = save_mode                          #save anti-sym or sym supermode
        self.filename_FDE_beta = filename_FDE_beta
        self.filename_FDE_D = filename_FDE_D
        self.filename_coeffi = filename_coeffi

        # beta_uncoupled_arr: shape = (?,4)   format: (wavl(unit:um),beta_WG1, beta_WG2, beta_ave(unit:rad/rad))
        self.beta_uncoupled_arr = self.Load_uncoupled_data(filename_uncoupled)
        # beta_coupled_arr:   shape = (?,3)   format: (wavl(unit:um),beta_supermode1, beta_supermode2(unit:rad/rad))
        self.beta_coupled_arr   = self.Load_coupled_data_CMT(filename_coupled)
        if self.filename_FDE_beta != "":
            self.beta_coupled_FDE_arr, self.beta_ave_FDE_arr = self.Load_coupled_beta_FDE(filename_FDE_beta, self.wavl_arr)
        if self.filename_FDE_D != "":
            self.D_coupled_FDE_arr = self.Load_coupled_D_FDE(filename_FDE_D, self.wavl_arr)

        gap_x, gap_y = self.gap_arr
        # If the gap is in y direction, the outer ring will be on the top of the inner ring, the radius is the same
        # If the gap is in x direction, the outer ring will be on the right of the inner ring, the radius is approxmated with the average of the two rings
        if gap_x > 0:
            self.bend_radius_outer = self.bend_radius_inner +\
                    gap_x + (self.WG1_width + self.WG2_width)/2       # unit :um
        else:
            self.bend_radius_outer = self.bend_radius_inner

        self.Calc_Dispersion_curve(num_of_pts = self.num_of_pts)

    # Load the propagation constants of the uncoupled modes
    def Load_uncoupled_data(self, filename_uncoupled):
        beta_uncoupled_arr = []
        with open(filename_uncoupled,'r') as f:
            data_uncoupled = f.readlines()
            for line in data_uncoupled[1:]:
                line = np.float64(line.split(","))
                # Only load data within the wavelength range of self.wavl_arr
                if line[0] < np.min(self.wavl_arr) or line[0] > np.max(self.wavl_arr):
                    continue
                beta_uncoupled_arr.append(line)
        beta_uncoupled_arr = np.array(beta_uncoupled_arr)
        return beta_uncoupled_arr

    # Load the propagation constants of the coupled modes calculated using CMT
    def Load_coupled_data_CMT(self, filename_coupled):
        beta_coupled_arr = []
        coeff_supermode_1_arr = []
        coeff_supermode_2_arr = []
        with open(filename_coupled,'r') as f:
            data_coupled = f.readlines()
            for line in data_coupled[1:]:
                line_split_list = line.split(",")
                line_float = np.float64(line_split_list[:3])
                # Only load data within the wavelength range of self.wavl_arr
                if line_float[0] < np.min(self.wavl_arr) or line_float[0] > np.max(self.wavl_arr):
                    continue
                # Make sure column 1 is supermode 1, which is the one with larger beta
                if line_float[1]<0:
                    beta_coupled = [line_float[0],line_float[2],line_float[1]]
                else:
                    beta_coupled = line_float[:3]
                assert len(beta_coupled) == 3
                assert len(line_split_list) == 7
                coeff_supermode_1 = [str2complex(line_split_list[3]),str2complex(line_split_list[4])]
                coeff_supermode_2 = [str2complex(line_split_list[5]),str2complex(line_split_list[6])]
                beta_coupled_arr.append(beta_coupled)
                coeff_supermode_1_arr.append(coeff_supermode_1)
                coeff_supermode_2_arr.append(coeff_supermode_2)

        beta_coupled_arr = np.array(beta_coupled_arr, dtype = np.float64)
        coeff_supermode_1_arr = np.array(coeff_supermode_1_arr, dtype = np.complex64)
        coeff_supermode_2_arr = np.array(coeff_supermode_2_arr, dtype = np.complex64)

        # Save the coefficients of the supermodes
        if self.filename_coeffi != "":
            with open(self.filename_coeffi,'w') as f:
                for wavl_idx in range(len(self.wavl_arr)):
                    f.write("{:.3f}".format(beta_coupled_arr[wavl_idx,0]) + ","
                        + '({0.real:.6f} + {0.imag:.6f}i),'.format(coeff_supermode_1_arr[wavl_idx,0])\
                        + '({0.real:.6f} + {0.imag:.6f}i),'.format(coeff_supermode_1_arr[wavl_idx,1])\
                        + '({0.real:.6f} + {0.imag:.6f}i),'.format(coeff_supermode_2_arr[wavl_idx,0])\
                        + '({0.real:.6f} + {0.imag:.6f}i)\n'.format(coeff_supermode_2_arr[wavl_idx,1])\
                        + "\n")
        return beta_coupled_arr

    def Load_coupled_beta_FDE(self, filename_FDE_beta, wavl_arr=[]):
        beta_coupled_FDE_arr_ori = []
        with open(filename_FDE_beta,'r') as f:
            data_FDE= f.readlines()
            beta_ang_mode1 = 0
            for line in data_FDE[2:]:
                line_split_list = line.split(",")
                wavelength  = float(line_split_list[0])/1000            #unit:um
                modeidx     = int(line_split_list[1])
                neff        = str2complex(line_split_list[2])
                ng          = str2complex(line_split_list[3])
                loss        = float(line_split_list[4])
                polarization= float(line_split_list[5])
                beta_ang    = float(line_split_list[6])
                # Only load data within the wavelength range of self.wavl_arr
                if wavelength < np.min(wavl_arr) or wavelength > np.max(wavl_arr):
                    continue
                if modeidx == 1:
                    # Mode 1
                    beta_ang_mode1 = beta_ang
                else:
                    # Mode 2
                    beta_ang_mode2 = beta_ang
                    beta_coupled_FDE_arr_ori.append([wavelength,beta_ang_mode1,beta_ang_mode2])

        beta_coupled_FDE_arr_ori = np.array(beta_coupled_FDE_arr_ori)
        beta_ave_arr = (beta_coupled_FDE_arr_ori[:,1] +
                        beta_coupled_FDE_arr_ori[:,2])/2
        beta_coupled_FDE_arr = np.copy(beta_coupled_FDE_arr_ori)
        beta_coupled_FDE_arr[:,1] = beta_coupled_FDE_arr_ori[:,1] - beta_ave_arr
        beta_coupled_FDE_arr[:,2] = beta_coupled_FDE_arr_ori[:,2] - beta_ave_arr
        return beta_coupled_FDE_arr, beta_ave_arr

    def Load_coupled_D_FDE(self, filename_FDE_D, wavl_arr):
        D_coupled_FDE_arr = []
        with open(filename_FDE_D,'r') as f:
            data_FDE= f.readlines()
            for line in data_FDE[1:]:
                line_split_list = line.split('\t')
                frequency   = float(line_split_list[0].strip())                         #unit:Hz
                wavelength  = self.c / frequency / um                                   #unit:um
                dispersion  = float(line_split_list[1].strip())/ um                     #unit: ps/nm/km
                # Only load data within the wavelength range of self.wavl_arr
                if wavelength < np.min(wavl_arr) or wavelength > np.max(wavl_arr):
                    continue
                D_coupled_FDE_arr.append([wavelength,dispersion])
        D_coupled_FDE_arr = np.flip(np.array(D_coupled_FDE_arr),axis=0)
        return D_coupled_FDE_arr

    def Load_isolated_dispersion_FDE(self,filename_FDE_beta="../data/Dispersion_of_isolated_inner_ring.txt"):
        D_FDE_arr = []
        with open(filename_FDE_beta,'r') as f:
            data_FDE= f.readlines()
            for line in data_FDE[1:]:
                fre         = float(line.split('\t')[0].strip())           # unit: Hz
                D           = float(line.split('\t')[1].strip()) / um      # unit: ps/km/nm
                wavl        = self.c/fre / um                              # unit: um
                D_FDE_arr.append([wavl,D])
        D_FDE_arr = np.array(D_FDE_arr)
        D_FDE_arr = np.flip(D_FDE_arr,axis=0)
        return D_FDE_arr

    def Polynomial_fit(self,x, y_arr, x_fit, order = 1, num_of_fit_pts  = 100):
        num_of_columns  = np.shape(y_arr)[1]
        coeffi_array    = np.zeros((order+1,num_of_columns))
        y_fit_arr       = np.zeros((num_of_fit_pts,num_of_columns))
        for idx in range(num_of_columns):
            y = y_arr[:,idx]
            coefficients = np.polyfit(x, y, order)
            coeffi_array[:,idx] = coefficients
            y_fit = np.polyval(coefficients, x_fit)
            y_fit_arr[:,idx] = y_fit
        return coeffi_array, y_fit_arr

    def Anomalous_D_bandwidth(self,wavl_arr,beta_supermode):
        start_idx = int(len(beta_supermode)/2)
        start_idx = np.argmax(beta_supermode)
        left_zero = wavl_arr[start_idx]
        right_zero = wavl_arr[start_idx]
        left_found = False
        right_found = False
        for delta_idx in range(int(len(beta_supermode)/2)):
            if (not right_found) and (start_idx + delta_idx < len(beta_supermode)-1):
                idx = start_idx + delta_idx
                if beta_supermode[idx] > 0 and beta_supermode[idx+1] < 0:
                    right_zero =  wavl_arr[idx] + (wavl_arr[idx+1]-wavl_arr[idx])*\
                            beta_supermode[idx]/(beta_supermode[idx]-beta_supermode[idx+1])
                    right_found = True
                    # print("Right Found, wavl:" + str(wavl_arr[idx]) + ", beta =" + str(beta_supermode[idx]))
                elif  beta_supermode[idx+1] > 0:
                    right_zero = wavl_arr[idx+1]

            if (not left_found) and (start_idx - delta_idx > 0):
                idx = start_idx - delta_idx
                if beta_supermode[idx] > 0 and beta_supermode[idx-1] < 0:
                    left_zero =  wavl_arr[idx] + (wavl_arr[idx-1]-wavl_arr[idx])*\
                            beta_supermode[idx]/(beta_supermode[idx]-beta_supermode[idx-1])
                    left_found = True
                    # print("Left Found, wavl:" + str(wavl_arr[idx]) + ", beta =" + str(beta_supermode[idx]))
                elif  beta_supermode[idx-1] > 0:
                    left_zero = wavl_arr[idx-1]

        return (left_zero*1e3,right_zero*1e3)   # nm

    # Beta      : unit: rad/m
    # wavl_arr  : unit: um
    def Calculate_dispersion_D(self,Beta,wavl_arr_):
        wavl_arr    = wavl_arr_ * um                                          #unit: m
        omega_arr   = 2*np.pi * Data_analyzer.c / (wavl_arr)                    #unit: rad/s
        Beta_1      = First_derivative_central_diff(Beta, omega_arr)
        Beta_1      = Beta_1 *1e12 * 1e3                                        # unit: ps/km
        D           = First_derivative_central_diff(Beta_1, wavl_arr[1:-1])
        D           = D * 1e-9                                                  # unit: ps/km/nm
        return D, Beta_1

    def Write_csv(self, gap, wavl_arr, D_WG, D_supermode,
                  filename_D_iso, filename_D_supermode):

        if not os.path.exists(filename_D_iso):
            df_iso = pd.DataFrame()
            df_iso['wavl'] = wavl_arr
        else:
            df_iso = pd.read_csv(filename_D_iso)
        df_iso[gap] = D_WG
        df_iso.to_csv(filename_D_iso, index=False, encoding="utf-8")

        if not os.path.exists(filename_D_supermode):
            df_coupled = pd.DataFrame()
            df_coupled['wavl'] = wavl_arr
        else:
            df_coupled = pd.read_csv(filename_D_supermode)
        df_coupled[gap] = D_supermode
        df_coupled.to_csv(filename_D_supermode, index=False, encoding="utf-8")

    # Interpolate the propagation constant data and calc the dispersion profile of FDE calculated modes
    def Calc_Dispersion_using_data_from_FDE(self,wavl_arr_FDE,
                                            wavl_arr_FDE_intp,
                                            num_of_pts):
        # unit: m
        R_WG1       = self.bend_radius_inner / 1e6
        R_WG2       = self.bend_radius_outer / 1e6
        R_ave       = (R_WG1+R_WG2)/2
        # Unbended waveguides
        if R_ave <0:
            R_ave = 1

        # Interpolating beta_ave in the range of wavl_arr_FDE
        coeffi_array, beta_ave_intp =  self.Polynomial_fit(wavl_arr_FDE,
                                    self.beta_ave_FDE_arr.reshape(-1,1),
                                    wavl_arr_FDE_intp, order=3, num_of_fit_pts=num_of_pts)

        beta_coupled_FDE_arr_intp  = Interpolation(wavl_arr_FDE,self.beta_coupled_FDE_arr[:,1:],wavl_arr_FDE_intp)
        # Adding beta_ave  # unit: 1/m
        beta_coupled_FDE_arr_intp = (beta_coupled_FDE_arr_intp + beta_ave_intp.reshape(-1,1)) /R_ave

        D_FDE_supermode_1_intp, Beta_1_lumerical_supermode_1_intp = self.Calculate_dispersion_D(beta_coupled_FDE_arr_intp[:,0],wavl_arr_FDE_intp)
        D_FDE_supermode_2_intp, Beta_1_lumerical_supermode_2_intp = self.Calculate_dispersion_D(beta_coupled_FDE_arr_intp[:,1],wavl_arr_FDE_intp)
        return D_FDE_supermode_1_intp,D_FDE_supermode_2_intp

    # Interpolate the propagation constant curve and calc the dispersion profile
    def Calc_Dispersion_curve(self,num_of_pts = 100):

        # unit: m
        R_WG1       = self.bend_radius_inner / 1e6
        R_WG2       = self.bend_radius_outer / 1e6
        R_ave       = (R_WG1+R_WG2)/2

        # Interpolate the propagation constant data
        self.beta_coupled_arr_intp  = Interpolation(self.wavl_arr, self.beta_coupled_arr[:,1:], self.wavl_arr_intp)
        coeffi_array, self.beta_uncoupled_arr_intp = self.Polynomial_fit(self.wavl_arr,
                                                        self.beta_uncoupled_arr[:,1:],
                                                        self.wavl_arr_intp,
                                                        3, num_of_pts)
        # Dispersion of Isolated WGs
        beta_uncoupled_WG1 = (self.beta_uncoupled_arr[:,1]+self.beta_uncoupled_arr[:,3])  / R_WG1     # unit: rad/m
        beta_uncoupled_WG2 = (self.beta_uncoupled_arr[:,2]+self.beta_uncoupled_arr[:,3])  / R_WG2     # unit: rad/m

        beta_uncoupled_WG1_intp = (self.beta_uncoupled_arr_intp[:,0]+
                                self.beta_uncoupled_arr_intp[:,2])  / R_WG1     # unit: rad/m
        beta_uncoupled_WG2_intp = (self.beta_uncoupled_arr_intp[:,1]+
                                self.beta_uncoupled_arr_intp[:,2])  / R_WG2     # unit: rad/m

        wavl_arr_FDE    = self.Load_isolated_dispersion_FDE()[:,0]
        D_WG1_FDE       = self.Load_isolated_dispersion_FDE()[:,1]
        D_WG2_FDE       = D_WG1_FDE
        _, D_WG1_intp   = self.Polynomial_fit(wavl_arr_FDE, D_WG1_FDE.reshape(-1,1),
                                              self.wavl_arr_intp, 3, num_of_pts)
        D_WG1_intp      = D_WG1_intp.reshape(-1,1)[2:-2]
        D_WG2_intp      = D_WG1_intp

        # Dispersion of coupled WGs using CMT
        beta_CMT_supermode1      = self.beta_coupled_arr[:,1]  / R_ave         # unit: rad/m
        beta_CMT_supermode2      = self.beta_coupled_arr[:,2]   / R_ave         # unit: rad/m
        beta_CMT_supermode1_intp = self.beta_coupled_arr_intp[:,0]  / R_ave    # unit: rad/m
        beta_CMT_supermode2_intp = self.beta_coupled_arr_intp[:,1]   / R_ave    # unit: rad/m

        D_supermode_1_intp, Beta_1_supermode_1_intp = self.Calculate_dispersion_D(beta_CMT_supermode1_intp,self.wavl_arr_intp)
        D_supermode_2_intp, Beta_1_supermode_2_intp = self.Calculate_dispersion_D(beta_CMT_supermode2_intp,self.wavl_arr_intp)

        # Adding the isolated dispersion
        D_supermode_1_intp = D_supermode_1_intp.reshape(-1,1) + D_WG1_intp.reshape(-1,1)
        D_supermode_2_intp = D_supermode_2_intp.reshape(-1,1) + D_WG2_intp.reshape(-1,1)

        # Maximum AD provided by vertically stacked rings
        # D_supermode_1_intp = 2*D_supermode_1_intp.reshape(-1,1) + D_WG1_intp.reshape(-1,1)
        # D_supermode_2_intp = 2*D_supermode_2_intp.reshape(-1,1) + D_WG2_intp.reshape(-1,1)

        Y_data = (np.c_[self.wavl_arr,
                        self.beta_uncoupled_arr[:,1:3],
                        self.beta_coupled_arr[:,1:]],
                  np.c_[self.wavl_arr_intp,
                        self.beta_coupled_arr_intp[:,:]],)
        if self.filename_FDE_beta != "":
            Y_data = Y_data + (self.beta_coupled_FDE_arr,)

        gap_info = " gap="+"({:.1f}um".format(self.gap_arr[0])+\
                    ","+"{:.1f}um)".format(self.gap_arr[1])

        # Plot propagation const curve
        if self.plot_curve:
            param_dict = {
                "Y_legends":
                [
                'Uncoupled inner ring',
                'Uncoupled outer ring',
                'Supermode 1 (CMT)','Supermode 2 (CMT)',
                'Supermode 1 (CMT) Interpolation',
                'Supermode 2 (CMT) Interpolation',
                'Supermode 1 (FDE)','Supermode 2 (FDE)',
                'beta_iso_inner','beta_iso_outer'],
                "X_label"       : r'wavelength($\mu m)$',
                "Y_label"       : r'$ \tilde{\beta}$ - $\bar{\beta}$(rad/rad)',
                "title"         : r"Propagation constant of coupled modes of 2D concentric rings",
                "autoset_yticks": 1,
                "marker_list"   :["","",".",".","","","o","o"],
                "linestyle_list":["dashed","dashdot","","","-","-","",""],
                "colors_list"   :['mediumturquoise','skyblue',
                                  'LightPink','crimson',
                                  'LightPink','crimson',
                                  'lightskyblue','dodgerblue']*2,
                "autoset_yticks": 0,
                "foldername"    : "./results/2D concentric rings/",
                "comment"       : gap_info
            }
            Plot_curve(Y_data,**param_dict)

        Y_data = (np.c_[self.wavl_arr_intp[2:-2],
                        D_WG1_intp,
                        D_WG2_intp,
                        D_supermode_1_intp, D_supermode_2_intp],)

        # Dispersion of coupled WGs using FDE (if exist)
        if self.filename_FDE_beta != "":
            wavl_arr_FDE_beta = self.beta_coupled_FDE_arr[:,0]    # unit: um
            wavl_arr_FDE_beta_intp = np.linspace(np.min(wavl_arr_FDE_beta),
                                                np.max(wavl_arr_FDE_beta),
                                                num_of_pts)
            D_FDE_supermode_1_intp, D_FDE_supermode_2_intp =self.Calc_Dispersion_using_data_from_FDE(wavl_arr_FDE_beta,wavl_arr_FDE_beta_intp,num_of_pts)
            Y_data = Y_data + (np.c_[wavl_arr_FDE_beta_intp[2:-2],
                      D_FDE_supermode_1_intp,D_FDE_supermode_2_intp],)

        if self.filename_FDE_D != "":
            wavl_arr_FDE_D = self.D_coupled_FDE_arr[:,0]    # unit: um
            wavl_arr_FDE_D_intp = np.linspace(np.min(wavl_arr_FDE_D),
                                                np.max(wavl_arr_FDE_D),
                                                num_of_pts)
            D_FDE_arr_intp  = Interpolation(wavl_arr_FDE_D,self.D_coupled_FDE_arr[:,1],wavl_arr_FDE_D_intp)
            Y_data = Y_data + (np.c_[wavl_arr_FDE_D_intp,D_FDE_arr_intp],)

        # Plot dispersion curve
        if self.plot_curve:
            xticks       = [self.wavl_arr_intp[i] for i in np.arange(0,len(self.wavl_arr_intp),15) ]
            xtickslabels = np.array(["{:.3f}".format(xtick) for xtick in xticks])
            param_dict = {
                "Y_legends"         : [
                                    'Inner Ring','Outer Ring',
                                    'Supermode 1 (CMT)','Supermode 2 (CMT)',
                                    # 'Supermode 1 (FDE)',
                                    'Supermode 2 (FDE)' ]*5,
                "X_label"           : r'wavelength($\mu m$)',
                "Y_label"           : r'$D(ps/nm/km)$',
                "title"             : r"Dispersion of coupled modes of 2D concentric rings",
                "xticks"            : xticks,
                "xtickslabel"       : xtickslabels,
                "marker_list"       : ["","","","","",""]*5,
                "linestyle_list"    : ["dashed","dashdot","-","-","-","-","-","-"]*2,
                "colors_list"       : ['mediumturquoise','skyblue','LightPink','crimson',
                                        # 'lightskyblue',
                                        'dodgerblue']*2,

                "AD_region_color"   : True,
                "autoset_yticks"    : 0,
                "foldername"        : "./results/2D concentric rings/",
                "comment"           : gap_info
                # "Y_legends"         : ['Uncoupled Ring','Supermode 1','Supermode 2']*5,
                # "comment"           : gap_info
                # "title"             : "Dispersion of 3D vertical stacked rings when gap="+ r"$2\mu m$",
                # "linestyle_list"    : ["--","-","-","-","-","-","-"]*5,
                # "colors_list"       : ['lightcoral','orange','dodgerblue','blue']*5,
                # "ylim"              : (-2000,1000),
            }
            Plot_curve(Y_data,**param_dict)

        gap_label = self.save_mode+"( double {:.2f}".format(self.gap_arr[0])+\
                    ","+"{:.2f})".format(self.gap_arr[1])
        D_WG_ave = (D_WG1_intp+D_WG2_intp)/2
        if self.save_D_in_csv:
            if self.save_mode == "AS":
                D_supermode = D_supermode_2_intp
            else:
                D_supermode = D_supermode_1_intp
            self.Write_csv(gap = gap_label, wavl_arr = self.wavl_arr_intp[2:-2],
                        D_WG=D_WG_ave, D_supermode=D_supermode,
                        filename_D_iso="./results/Dispersion_isolated_WG.csv",
                        filename_D_supermode="./results/Dispersion_coupled_WG.csv")

