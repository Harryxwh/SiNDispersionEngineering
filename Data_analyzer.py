import pandas as pd
import os
from Functions import *
from Coupled_Waveguides import *
'''
class Data_analyzer:
This class is used to analyze the data generated by the Parameter Sweeper class.
It can load the propagation constant data of the uncoupled and coupled modes, and calculate the dispersion curve.
It can also load the propagation constant or dispersion data of the FDE calculated modes and compare the results.
The results are saved in a csv file and can be plotted.

Parameters:
-------------------------------------------------------------------------------------
Compulsory:
wavl_arr            : array of wavlengths   (unit: nm)
gap                 : (gap_x,gap_y). gap between the two WGs in x or y direction   (unit: um)
param_filename      : filename of parameters, format: csv
filename_uncoupled  : filename of uncoupled modes data generated by class "Parameter Sweeper"
filename_coupled    : filename of coupled modes data generated by class "Parameter Sweeper"
foldername_1        : foldername of mode profile data of WG1
foldername_2        : foldername of mode profile data of WG2
num_of_pts          : num of points when interpolating the beta arr, default: 100
-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------
FDE data to compare with (optional):
filename_FDE_beta   : filename of FDE calculated beta data. if "", not loaded.
filename_FDE_beta   : filename of FDE calculated Dispersion data. if "", not loaded.
-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------
Plot and save options:
title               : title of the plot
plot_curve          : whether to plot the dispersion curve, default: True
save_D_in_csv       : whether to save the calculated dispersion curve as a csv, default: True
save_mode           : to save the dispersion of which supermode, "AS" (anti-symmetric) or "S" (symmetric). "AS" by default
plot_profile        : whether to plot the supermode profile, default: False
plot_log_scale      : whether to plot the supermode profile in log scale, default: False
save_foldername     : foldername to save the results
-------------------------------------------------------------------------------------

Author: Weihao Xu
Date: May. 8th, 2025
'''

class Data_analyzer():

    def __init__(self, wavl_arr, gap, param_filename,
                 filename_uncoupled, filename_coupled,
                 foldername_1, foldername_2, num_of_pts = 100,
                 filename_FDE_beta = "", filename_FDE_D = "",
                 name_structure = "2D concentric rings",
                 plot_curve = True, save_D_in_csv = True, save_mode = "AS",
                 plot_profile = False, plot_log_scale = False,
                 save_foldername = "./results/"):

        self.wavl_arr = wavl_arr/1000                       #unit: um
        self.gap = gap
        self.param_filename = param_filename
        self.Load_param(param_filename)
        self.foldername_1 = foldername_1
        self.foldername_2 = foldername_2
        self.num_of_pts = num_of_pts

        self.filename_FDE_beta = filename_FDE_beta
        self.filename_FDE_D = filename_FDE_D

        self.name_structure = name_structure
        self.plot_curve = plot_curve
        self.save_D_in_csv = save_D_in_csv
        self.save_mode = save_mode                          #save anti-sym or sym supermode
        self.save_foldername = save_foldername

        self.wavl_arr_intp = np.linspace(np.min(self.wavl_arr),np.max(self.wavl_arr),
                            self.num_of_pts)   #unit: um

        # beta_uncoupled_arr: shape = (?,4)   format: (wavl(unit:um),beta_WG1, beta_WG2, beta_ave(unit:rad/rad))
        self.beta_uncoupled_arr = self.Load_uncoupled_data(filename_uncoupled)
        # beta_coupled_arr:   shape = (?,3)   format: (wavl(unit:um),beta_supermode1, beta_supermode2(unit:rad/rad))
        self.beta_coupled_arr,self.coeff_supermode_1_arr,self.coeff_supermode_2_arr = self.Load_coupled_data_CMT(filename_coupled)
        if self.filename_FDE_beta != "":
            self.beta_coupled_FDE_arr, self.beta_ave_FDE_arr = self.Load_coupled_beta_FDE(filename_FDE_beta, self.wavl_arr)
        if self.filename_FDE_D != "":
            self.D_coupled_FDE_arr = self.Load_coupled_D_FDE(filename_FDE_D, self.wavl_arr)

        gap_x, gap_y = self.gap
        # If the gap is in y direction, the outer ring will be on the top of the inner ring, the radius is the same
        # If the gap is in x direction, the outer ring will be on the right of the inner ring, the radius is approxmated with the average of the two rings
        if gap_x > 0:
            self.bend_radius_outer = self.bend_radius_inner +\
                    gap_x + (self.WG1_width + self.WG2_width)/2       # unit :um
        else:
            self.bend_radius_outer = self.bend_radius_inner

        self.Calc_Dispersion_curve(num_of_pts = self.num_of_pts)

        if plot_profile:
            self.Plot_supermodes_profiles(wavl_arr, plot_log = plot_log_scale)   # wavl_arr is in nm

    # Load the class variables from Param.csv
    def Load_param(self, param_file_name):
        dtype = [('key', str), ('value', str),('dtype', str), ('comments', str)]
        data = np.loadtxt(param_file_name, delimiter=',', dtype=str, skiprows=1)
        for param in data:
            exec("self."+param[0]+" = "+param[2]+"("+param[1]+")")

    # Load the propagation constants of the uncoupled modes
    def Load_uncoupled_data(self, filename_uncoupled):
        beta_uncoupled_arr = []
        with open(filename_uncoupled,'r') as f:
            data_uncoupled = f.readlines()
            for line in data_uncoupled[1:]:
                line = np.float64(line.split(","))
                # Only load data within the wavelength range of self.wavl_arr
                if line[0] < np.min(self.wavl_arr) or line[0] > np.max(self.wavl_arr):
                    continue
                beta_uncoupled_arr.append(line)
        beta_uncoupled_arr = np.array(beta_uncoupled_arr)
        return beta_uncoupled_arr

    # Load the propagation constants of the coupled modes calculated using CMT
    def Load_coupled_data_CMT(self, filename_coupled):
        beta_coupled_arr = []
        coeff_supermode_1_arr = []
        coeff_supermode_2_arr = []
        with open(filename_coupled,'r') as f:
            data_coupled = f.readlines()
            for line in data_coupled[1:]:
                line_split_list = line.split(",")
                line_float = np.float64(line_split_list[:3])
                # Only load data within the wavelength range of self.wavl_arr
                if line_float[0] < np.min(self.wavl_arr) or line_float[0] > np.max(self.wavl_arr):
                    continue
                # Make sure column 1 is supermode 1, which is the one with larger beta
                if line_float[1]<0:
                    beta_coupled = [line_float[0],line_float[2],line_float[1]]
                else:
                    beta_coupled = line_float[:3]
                assert len(beta_coupled) == 3
                assert len(line_split_list) == 7
                coeff_supermode_1 = [str2complex(line_split_list[3]),str2complex(line_split_list[4])]
                coeff_supermode_2 = [str2complex(line_split_list[5]),str2complex(line_split_list[6])]
                beta_coupled_arr.append(beta_coupled)
                coeff_supermode_1_arr.append(coeff_supermode_1)
                coeff_supermode_2_arr.append(coeff_supermode_2)

        beta_coupled_arr = np.array(beta_coupled_arr, dtype = np.float64)
        coeff_supermode_1_arr = np.array(coeff_supermode_1_arr, dtype = np.complex64)
        coeff_supermode_2_arr = np.array(coeff_supermode_2_arr, dtype = np.complex64)

        return beta_coupled_arr,coeff_supermode_1_arr,coeff_supermode_2_arr

    # Load the propagation constants of the coupled modes calculated using FDE
    # Parameters:
    # filename_FDE_beta: filename of the FDE calculated beta data
    # wavl_arr: unit: um
    # Outputs:
    # beta_coupled_FDE_arr: The propagation constants of the two supermodes. format: (wavl(unit:um),beta_supermode1, beta_supermode2(unit:rad/rad)) (beta_ave has been deducted from the last two columns)
    # beta_ave_FDE_arr: The average of the propagation constants of the two supermodes. format: (wavl(unit:um),beta_ave(unit:rad/rad))
    def Load_coupled_beta_FDE(self, filename_FDE_beta, wavl_arr=[]):
        beta_coupled_FDE_arr_ori = []
        with open(filename_FDE_beta,'r') as f:
            data_FDE= f.readlines()
            beta_ang_mode1 = 0
            for line in data_FDE[2:]:
                line_split_list = line.split(",")
                wavelength  = float(line_split_list[0])/1000            #unit:um
                modeidx     = int(line_split_list[1])
                neff        = str2complex(line_split_list[2])
                ng          = str2complex(line_split_list[3])
                loss        = float(line_split_list[4])
                polarization= float(line_split_list[5])
                beta_ang    = float(line_split_list[6])
                # Only load data within the wavelength range of self.wavl_arr
                if wavelength < np.min(wavl_arr) or wavelength > np.max(wavl_arr):
                    continue
                if modeidx == 1:
                    # Mode 1
                    beta_ang_mode1 = beta_ang
                else:
                    # Mode 2
                    beta_ang_mode2 = beta_ang
                    beta_coupled_FDE_arr_ori.append([wavelength,beta_ang_mode1,beta_ang_mode2])

        beta_coupled_FDE_arr_ori = np.array(beta_coupled_FDE_arr_ori)
        beta_ave_arr = (beta_coupled_FDE_arr_ori[:,1] +
                        beta_coupled_FDE_arr_ori[:,2])/2
        beta_coupled_FDE_arr = np.copy(beta_coupled_FDE_arr_ori)
        beta_coupled_FDE_arr[:,1] = beta_coupled_FDE_arr_ori[:,1] - beta_ave_arr
        beta_coupled_FDE_arr[:,2] = beta_coupled_FDE_arr_ori[:,2] - beta_ave_arr
        return beta_coupled_FDE_arr, beta_ave_arr

    # Load the dispersion of the coupled modes calculated using FDE
    # Parameters:
    # filename_FDE_D: filename of the FDE calculated dispersion data
    # wavl_arr: unit: um
    # Outputs:
    # D_coupled_FDE_arr: shape = (?,2). format: (wavl(unit:um),D(unit:ps/nm/km))
    def Load_coupled_D_FDE(self, filename_FDE_D, wavl_arr):
        D_coupled_FDE_arr = []
        with open(filename_FDE_D,'r') as f:
            data_FDE= f.readlines()
            for line in data_FDE[1:]:
                line_split_list = line.split('\t')
                frequency   = float(line_split_list[0].strip())                         #unit:Hz
                wavelength  = c / frequency / um                                   #unit:um
                dispersion  = float(line_split_list[1].strip())/ um                     #unit: ps/nm/km
                # Only load data within the wavelength range of self.wavl_arr
                if wavelength < np.min(wavl_arr) or wavelength > np.max(wavl_arr):
                    continue
                D_coupled_FDE_arr.append([wavelength,dispersion])
        D_coupled_FDE_arr = np.flip(np.array(D_coupled_FDE_arr),axis=0)
        return D_coupled_FDE_arr

    # Load the dispersion of the isolated modes calculated using FDE
    # Parameters:
    # filename_FDE_beta: filename of the FDE calculated beta data
    # Outputs:
    # D_uncoupled_FDE_arr: shape = (?,2). format: (wavl(unit:um),D(unit:ps/nm/km))
    def Load_isolated_dispersion_FDE(self,filename_FDE_beta="../data/Dispersion_of_isolated_inner_ring.txt"):
        D_uncoupled_FDE_arr = []
        with open(filename_FDE_beta,'r') as f:
            data_FDE= f.readlines()
            for line in data_FDE[1:]:
                fre         = float(line.split('\t')[0].strip())           # unit: Hz
                D           = float(line.split('\t')[1].strip()) / um      # unit: ps/km/nm
                wavl        = c/ fre / um                              # unit: um
                D_uncoupled_FDE_arr.append([wavl,D])
        D_uncoupled_FDE_arr = np.array(D_uncoupled_FDE_arr)
        D_uncoupled_FDE_arr = np.flip(D_uncoupled_FDE_arr,axis=0)
        return D_uncoupled_FDE_arr

    # Polynomial fitting, multiple y data with the same x data can be fitted at the same time.
    # Parameters:
    # x: x data
    # y_arr: y data, shape = (?,num_of_columns)
    # x_fit: x data for fitting
    # order: order of the polynomial. if 1, linear fit, if 2, quadratic fit.
    # num_of_fit_pts: num of points for fitting
    def Polynomial_fit(self,x, y_arr, x_fit, order = 1, num_of_fit_pts  = 100):
        num_of_columns  = np.shape(y_arr)[1]
        coeffi_array    = np.zeros((order+1,num_of_columns))
        y_fit_arr       = np.zeros((num_of_fit_pts,num_of_columns))
        for idx in range(num_of_columns):
            y = y_arr[:,idx]
            coefficients = np.polyfit(x, y, order)
            coeffi_array[:,idx] = coefficients
            y_fit = np.polyval(coefficients, x_fit)
            y_fit_arr[:,idx] = y_fit
        return coeffi_array, y_fit_arr

    # Calculate the Anomalous Dispersion range of the supermode
    def Anomalous_D_bandwidth(self,wavl_arr,beta_supermode):
        start_idx = int(len(beta_supermode)/2)
        start_idx = np.argmax(beta_supermode)
        left_zero = wavl_arr[start_idx]
        right_zero = wavl_arr[start_idx]
        left_found = False
        right_found = False
        for delta_idx in range(int(len(beta_supermode)/2)):
            if (not right_found) and (start_idx + delta_idx < len(beta_supermode)-1):
                idx = start_idx + delta_idx
                if beta_supermode[idx] > 0 and beta_supermode[idx+1] < 0:
                    right_zero =  wavl_arr[idx] + (wavl_arr[idx+1]-wavl_arr[idx])*\
                            beta_supermode[idx]/(beta_supermode[idx]-beta_supermode[idx+1])
                    right_found = True
                elif  beta_supermode[idx+1] > 0:
                    right_zero = wavl_arr[idx+1]

            if (not left_found) and (start_idx - delta_idx > 0):
                idx = start_idx - delta_idx
                if beta_supermode[idx] > 0 and beta_supermode[idx-1] < 0:
                    left_zero =  wavl_arr[idx] + (wavl_arr[idx-1]-wavl_arr[idx])*\
                            beta_supermode[idx]/(beta_supermode[idx]-beta_supermode[idx-1])
                    left_found = True
                elif  beta_supermode[idx-1] > 0:
                    left_zero = wavl_arr[idx-1]

        return (left_zero*1e3,right_zero*1e3)   # nm

    # Beta      : unit: rad/m
    # wavl_arr  : unit: um
    def Calculate_dispersion_D(self,Beta,wavl_arr_):
        wavl_arr    = wavl_arr_ * um                                          #unit: m
        omega_arr   = 2*np.pi * c / (wavl_arr)                    #unit: rad/s
        Beta_1      = First_derivative_central_diff(Beta, omega_arr)
        Beta_1      = Beta_1 *1e12 * 1e3                                        # unit: ps/km
        D           = First_derivative_central_diff(Beta_1, wavl_arr[1:-1])
        D           = D * 1e-9                                                  # unit: ps/km/nm
        return D, Beta_1

    # Write the dispersion data to csv file. Method of opening the file is "append", so previous data will not be erased.
    def Write_D_in_csv(self, gap, wavl_arr, D_WG, D_supermode,
                  filename_D_iso, filename_D_supermode):
        if not os.path.exists(filename_D_iso):
            df_iso = pd.DataFrame()
            df_iso['wavl'] = wavl_arr
        else:
            df_iso = pd.read_csv(filename_D_iso)
        try:
            df_iso[gap] = D_WG
            df_iso.to_csv(filename_D_iso, index=False, encoding="utf-8")

            if not os.path.exists(filename_D_supermode):
                df_coupled = pd.DataFrame()
                df_coupled['wavl'] = wavl_arr
            else:
                df_coupled = pd.read_csv(filename_D_supermode)
            df_coupled[gap] = D_supermode
            df_coupled.to_csv(filename_D_supermode, index=False, encoding="utf-8")
        except ValueError:
            print("------------------------------------------------")
            print("ERROR: The length of the wavlength arr in the csv file does not match with the given parameter wavl_arr. Please change num_of_pts accordingly or delete the csv file.")
            print("------------------------------------------------")
            return

    # Interpolate the propagation constant data and calc the dispersion profile of FDE calculated modes
    def Calc_Dispersion_using_data_from_FDE(self,wavl_arr_FDE,
                                            wavl_arr_FDE_intp,
                                            num_of_pts):
        # unit: m
        R_WG1       = self.bend_radius_inner / 1e6
        R_WG2       = self.bend_radius_outer / 1e6
        R_ave       = (R_WG1+R_WG2)/2
        # Unbended waveguides
        if R_ave <0:
            R_ave = 1

        # Interpolating beta_ave in the range of wavl_arr_FDE
        coeffi_array, beta_ave_intp =  self.Polynomial_fit(wavl_arr_FDE,
                                    self.beta_ave_FDE_arr.reshape(-1,1),
                                    wavl_arr_FDE_intp, order=3, num_of_fit_pts=num_of_pts)

        beta_coupled_FDE_arr_intp  = Interpolation(wavl_arr_FDE,self.beta_coupled_FDE_arr[:,1:],wavl_arr_FDE_intp)

        # Adding beta_ave  # unit: 1/m
        beta_coupled_FDE_arr_intp = (beta_coupled_FDE_arr_intp + beta_ave_intp.reshape(-1,1)) /R_ave

        D_FDE_supermode_1_intp, Beta_1_lumerical_supermode_1_intp = self.Calculate_dispersion_D(beta_coupled_FDE_arr_intp[:,0],wavl_arr_FDE_intp)
        D_FDE_supermode_2_intp, Beta_1_lumerical_supermode_2_intp = self.Calculate_dispersion_D(beta_coupled_FDE_arr_intp[:,1],wavl_arr_FDE_intp)
        return D_FDE_supermode_1_intp,D_FDE_supermode_2_intp

    # Interpolate the propagation constant curve and calc the dispersion profile
    def Calc_Dispersion_curve(self,num_of_pts = 100):

        # unit: m
        R_WG1       = self.bend_radius_inner / 1e6
        R_WG2       = self.bend_radius_outer / 1e6
        R_ave       = (R_WG1+R_WG2)/2

        # Interpolate the propagation constant data
        try:
            self.beta_coupled_arr_intp  = Interpolation(self.wavl_arr, self.beta_coupled_arr[:,1:], self.wavl_arr_intp)
            coeffi_array, self.beta_uncoupled_arr_intp = self.Polynomial_fit(self.wavl_arr,
                                                            self.beta_uncoupled_arr[:,1:],
                                                            self.wavl_arr_intp,
                                                            3, num_of_pts)
        except ValueError:
            print("------------------------------------------------")
            print("ERROR: The length of wavl_arr doesn't match the length of beta_arr (CMT). Please check the wavlength range of the data files and set wavl_arr accordingly.")
            print("------------------------------------------------")
            return

        # Dispersion of Isolated WGs
        beta_uncoupled_WG1 = (self.beta_uncoupled_arr[:,1]+self.beta_uncoupled_arr[:,3])  / R_WG1     # unit: rad/m
        beta_uncoupled_WG2 = (self.beta_uncoupled_arr[:,2]+self.beta_uncoupled_arr[:,3])  / R_WG2     # unit: rad/m

        beta_uncoupled_WG1_intp = (self.beta_uncoupled_arr_intp[:,0]+
                                self.beta_uncoupled_arr_intp[:,2])  / R_WG1     # unit: rad/m
        beta_uncoupled_WG2_intp = (self.beta_uncoupled_arr_intp[:,1]+
                                self.beta_uncoupled_arr_intp[:,2])  / R_WG2     # unit: rad/m

        wavl_arr_FDE    = self.Load_isolated_dispersion_FDE()[:,0]
        D_WG1_FDE       = self.Load_isolated_dispersion_FDE()[:,1]
        D_WG2_FDE       = D_WG1_FDE
        _, D_WG1_intp   = self.Polynomial_fit(wavl_arr_FDE, D_WG1_FDE.reshape(-1,1),
                                              self.wavl_arr_intp, 3, num_of_pts)
        D_WG1_intp      = D_WG1_intp.reshape(-1,1)[2:-2]
        D_WG2_intp      = D_WG1_intp

        # Dispersion of coupled WGs using CMT
        beta_CMT_supermode1      = self.beta_coupled_arr[:,1]  / R_ave         # unit: rad/m
        beta_CMT_supermode2      = self.beta_coupled_arr[:,2]   / R_ave         # unit: rad/m
        beta_CMT_supermode1_intp = self.beta_coupled_arr_intp[:,0]  / R_ave    # unit: rad/m
        beta_CMT_supermode2_intp = self.beta_coupled_arr_intp[:,1]   / R_ave    # unit: rad/m

        D_supermode_1_intp, Beta_1_supermode_1_intp = self.Calculate_dispersion_D(beta_CMT_supermode1_intp,self.wavl_arr_intp)
        D_supermode_2_intp, Beta_1_supermode_2_intp = self.Calculate_dispersion_D(beta_CMT_supermode2_intp,self.wavl_arr_intp)

        # Adding the isolated dispersion
        D_supermode_1_intp = D_supermode_1_intp.reshape(-1,1) + D_WG1_intp.reshape(-1,1)
        D_supermode_2_intp = D_supermode_2_intp.reshape(-1,1) + D_WG2_intp.reshape(-1,1)

        # Maximum AD provided by vertically stacked rings
        # D_supermode_1_intp = 2*D_supermode_1_intp.reshape(-1,1) + D_WG1_intp.reshape(-1,1)
        # D_supermode_2_intp = 2*D_supermode_2_intp.reshape(-1,1) + D_WG2_intp.reshape(-1,1)

        Y_data = (np.c_[self.wavl_arr,
                        self.beta_uncoupled_arr[:,1:3],
                        self.beta_coupled_arr[:,1:]],
                  np.c_[self.wavl_arr_intp,
                        self.beta_coupled_arr_intp[:,:]],)
        if self.filename_FDE_beta != "":
            Y_data = Y_data + (self.beta_coupled_FDE_arr,)

        gap_info = " gap="+"({:.1f}um".format(self.gap[0])+\
                    ","+"{:.1f}um)".format(self.gap[1])

        # Plot propagation const curve
        if self.plot_curve:
            param_dict = {
                "Y_legends":
                ['Uncoupled inner ring','Uncoupled outer ring',
                'Supermode 1 (CMT)','Supermode 2 (CMT)',
                'Supermode 1 (CMT) Interpolation',
                'Supermode 2 (CMT) Interpolation',
                'Supermode 1 (FDE)','Supermode 2 (FDE)',
                'beta_iso_inner','beta_iso_outer'],
                "X_label"       : r'wavelength($\mu m)$',
                "Y_label"       : r'$ \tilde{\beta}$ - $\bar{\beta}$(rad/rad)',
                "title"         : r"Propagation constant of coupled modes of " + self.name_structure,
                "autoset_yticks": 1,
                "marker_list"   :["","",".",".","","","o","o"],
                "linestyle_list":["dashed","dashdot","","","-","-","",""],
                "colors_list"   :['mediumturquoise','skyblue',
                                  'LightPink','crimson',
                                  'LightPink','crimson',
                                  'lightskyblue','dodgerblue']*2,
                "autoset_yticks": 0,
                "foldername"    : "./results/2D concentric rings/",
                "comment"       : gap_info
            }
            Plot_curve(Y_data,**param_dict)

        Y_data = (np.c_[self.wavl_arr_intp[2:-2],
                        D_WG1_intp,D_WG2_intp,
                        D_supermode_1_intp, D_supermode_2_intp],)
        Y_legends = ['Inner Ring','Outer Ring','Supermode 1 (CMT)','Supermode 2 (CMT)']
        colors_list =  ['mediumturquoise','skyblue','LightPink','crimson']

        # Propagation constant of coupled WGs using FDE (if exist)
        if self.filename_FDE_beta != "":
            wavl_arr_FDE_beta = self.beta_coupled_FDE_arr[:,0]    # unit: um
            wavl_arr_FDE_beta_intp = np.linspace(np.min(wavl_arr_FDE_beta),
                                                np.max(wavl_arr_FDE_beta),
                                                num_of_pts)
            D_FDE_supermode_1_intp, D_FDE_supermode_2_intp =self.Calc_Dispersion_using_data_from_FDE(wavl_arr_FDE_beta,wavl_arr_FDE_beta_intp,num_of_pts)
            Y_data = Y_data + (np.c_[wavl_arr_FDE_beta_intp[2:-2],
                      D_FDE_supermode_1_intp,D_FDE_supermode_2_intp],)
            Y_legends = Y_legends + ['Supermode 1 (using beta from FDE)','Supermode 2 (using beta from FDE)']+['']*5
            colors_list = colors_list + ['lightskyblue','dodgerblue']+['black']*5

        # Dispersion of coupled WGs using FDE (if exist)
        if self.filename_FDE_D != "":
            wavl_arr_FDE_D = self.D_coupled_FDE_arr[:,0]    # unit: um
            wavl_arr_FDE_D_intp = np.linspace(np.min(wavl_arr_FDE_D),
                                                np.max(wavl_arr_FDE_D),
                                                num_of_pts)
            D_FDE_arr_intp  = Interpolation(wavl_arr_FDE_D,self.D_coupled_FDE_arr[:,1],wavl_arr_FDE_D_intp)
            Y_data_add = np.c_[wavl_arr_FDE_D_intp,D_FDE_arr_intp]
            Y_data = Y_data + (Y_data_add,)
            # if the symmetric supermode is not calculated, only plot the second supermode
            if np.shape(Y_data_add)[1] == 3:
                Y_legends = Y_legends + ['Supermode 1 (FDE)','Supermode 2 (FDE)']+['']*5
                colors_list = colors_list + ['lightskyblue','dodgerblue']+['black']*5
            else:
                Y_legends = Y_legends + ['Supermode 2 (FDE)']+['']*5
                colors_list = colors_list + ['dodgerblue']+['black']*5

        # Plot dispersion curve
        if self.plot_curve:
            xticks       = [self.wavl_arr_intp[i] for i in np.arange(0,len(self.wavl_arr_intp),100) ]
            xtickslabels = np.array(["{:.3f}".format(xtick) for xtick in xticks])

            param_dict = {
                "Y_legends"         : Y_legends,
                "X_label"           : r'wavelength($\mu m$)',
                "Y_label"           : r'$D(ps/nm/km)$',
                "title"             : r"Dispersion of coupled modes of " + self.name_structure,
                "xticks"            : xticks,
                "xtickslabel"       : xtickslabels,
                "marker_list"       : ["","","","","",""]*5,
                "linestyle_list"    : ["dashed","dashdot","-","-","-","-","-","-"]*2,
                "colors_list"       : colors_list,
                "AD_region_color"   : True,
                "autoset_yticks"    : 0,
                "foldername"        : "./results/2D concentric rings/",
                "comment"           : gap_info
                # "Y_legends"         : ['Uncoupled Ring','Supermode 1','Supermode 2']*5,
                # "comment"           : gap_info
                # "title"             : "Dispersion of 3D vertical stacked rings when gap="+ r"$2\mu m$",
                # "linestyle_list"    : ["--","-","-","-","-","-","-"]*5,
                # "colors_list"       : ['lightcoral','orange','dodgerblue','blue']*5,
                # "ylim"              : (-2000,1000),
            }
            Plot_curve(Y_data,**param_dict)

        gap_label = self.save_mode+"({:.2f}".format(self.gap[0])+\
                    ","+"{:.2f})".format(self.gap[1])
        D_WG_ave = (D_WG1_intp+D_WG2_intp)/2
        if self.save_D_in_csv:
            if self.save_mode == "AS":
                D_supermode = D_supermode_2_intp
            else:
                D_supermode = D_supermode_1_intp
            self.Write_D_in_csv(gap = gap_label, wavl_arr = self.wavl_arr_intp[2:-2],
                        D_WG=D_WG_ave, D_supermode=D_supermode,
                        filename_D_iso = self.save_foldername + "Dispersion_isolated_WG.csv",
                        filename_D_supermode = self.save_foldername + "Dispersion_coupled_WG.csv")

    # Plot field profile of supermodes
    def Plot_supermodes_profiles(self, wavl_arr_in_nm, plot_log = False):
        for idx, wavl_in_nm in enumerate(wavl_arr_in_nm):
            wavl_in_um = wavl_in_nm / 1000
            coeff_arr = np.r_[self.coeff_supermode_1_arr[idx,:].reshape(1,-1),
                              self.coeff_supermode_2_arr[idx,:].reshape(1,-1)]
            gap_x,gap_y = self.gap
            path_1 = self.foldername_1 +'/'+ "{:.0f}".format(wavl_in_nm)
            path_2 = self.foldername_2 +'/'+ "{:.0f}".format(wavl_in_nm)
            Coupled_WG = Coupled_Waveguides(wavelength = wavl_in_um,
                                gap_x = gap_x, gap_y = gap_y,
                                name1 = path_1,name2 = path_2,
                                ModeIdx1 = 1, ModeIdx2 = 1,
                                param_file_name = self.param_filename,
                                save_foldername = self.save_foldername)
            Coupled_WG.Plot_field_profile(coeff_arr , field_name = 'Ex',
                                title=r"Electric field profile when wavl = "+"{:.0f}".format(wavl_in_nm)+" nm",
                                Plot_log=plot_log)
